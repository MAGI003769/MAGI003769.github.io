{"title":"Binary Tree（2）","date":"2019-04-15T07:00:00.000Z","date_formatted":{"ll":"Apr 15, 2019","L":"04/15/2019","MM-DD":"04-15"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/alice-donovan-rouse-177313-unsplash.jpg","link":"post/Tree-02","tags":["Binary Tree","LeetCode"],"categories":["算法数据结构"],"updated":"2019-05-19T22:46:26.000Z","content":"<p>这一篇post是之前Binary Tree的后续，主要记录一些Binary Tree相关的题目。其实LeetCode上有很多题是相同或者存在极大关联的，基本思想都差不多，一道解决了，其他的也就都解决了。解法的分析也尽量将递归和迭代两种方法都实现一下（当然我也只是尽量，迭代方法还真不一定看得懂）。</p>\n<a id=\"more\"></a><h1 id=\"find-path\">Find Path<a href=\"#find-path\" title=\"Find Path\"></a></h1><p>这类题目基本上就是按要求找从 <code>root</code> 出发到<code>leaf</code>的路径。<a href=\"https://leetcode.com/problems/binary-tree-paths/\" target=\"_blank\">257. Binary Tree Paths</a>、<a href=\"https://leetcode.com/problems/path-sum-ii/submissions/\" target=\"_blank\">Path Sum II</a>和<a href=\"https://leetcode.com/problems/sum-root-to-leaf-numbers/\" target=\"_blank\">129. Sum Root to Leaf Numbers</a>这几个题目思路基本思路几乎是一模一样的，所以就挑其中的129讲一下.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sumNumbers</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self._pathSum(root, root.val, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum(ans)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_pathSum</span><span class=\"params\">(self, node, sum_, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left == <span class=\"literal\">None</span> <span class=\"keyword\">and</span> node.right == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            ans.append(sum_)</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left:</span><br><span class=\"line\">            self._pathSum(node.left, sum_ * <span class=\"number\">10</span> + node.left.val, ans)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.right:</span><br><span class=\"line\">            self._pathSum(node.right, sum_ * <span class=\"number\">10</span> + node.right.val, ans)</span><br></pre></td></tr></table></figure><h1 id=\"depth-of-tree\">Depth of Tree<a href=\"#depth-of-tree\" title=\"Depth of Tree\"></a></h1><p>这个题型实际上已经在之前的一篇post里讨论过了，这里有拿出来是因为遇到了一个会用到这个的相关题目。这也是和前面的路径寻找相类似的常见问题。</p>\n<h2 id=\"maximum-depth-of-binary-tree\">Maximum Depth of Binary Tree<a href=\"#maximum-depth-of-binary-tree\" title=\"Maximum Depth of Binary Tree\"></a></h2><p>我们依然用递归的方法，当目前节点为<code>Null</code>时，返回0,。因此对于二叉树最深处的某个节点，它所返回的深度应该是1。以此类推，即可获得二叉树的最大深度</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth_btop</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><h2 id=\"diameter-of-binary-tree\">Diameter of Binary Tree<a href=\"#diameter-of-binary-tree\" title=\"Diameter of Binary Tree\"></a></h2><p><a href=\"https://leetcode.com/problems/diameter-of-binary-tree/\" target=\"_blank\">543. Diameter of Binary Tree</a>这道题虽然是一个easy，思路也没有很难，但是我还是绕了半天。下面是一个错误答案，我的思路开始是把 <code>root</code> 的左右最大的深度加在一起，这样就是diameter了。但是我忽略了左右非常不平衡的情况，比如左边的substree很深而且有很多节点，而右边的subtree很浅，甚至更极端的情况只有一个节点。这样，使用<code>root</code>两侧的深度相加的想法就是不行的了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> root:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root.left == <span class=\"literal\">None</span> <span class=\"keyword\">and</span> root.right == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self._getDepth(root.left)</span><br><span class=\"line\">        right = self._getDepth(root.right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left + right</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_getDepth</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(self._getDepth(node.left), self._getDepth(node.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><p>由上面的分析可以得出，我们需要在subtree的部分也进行遍历，对每个节点的subtree进行直径计算，来寻找最大。我们依然使用某一节点两侧相加为最大，但是我们会在每次计算之后比较大小，如果需要则更新结果。下面是一个正确答案。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        self.max = <span class=\"number\">0</span></span><br><span class=\"line\">        self._getDepth(root)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.max</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_getDepth</span><span class=\"params\">(self, node)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        left = self._getDepth(node.left)</span><br><span class=\"line\">        right = self._getDepth(node.right)</span><br><span class=\"line\">        self.max = max(self.max, left + right)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(left, right) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><h1 id=\"construct-tree\">Construct Tree<a href=\"#construct-tree\" title=\"Construct Tree\"></a></h1><p>这部分我是真的迷。等我再研究研究，希望能把坑填上。答案先贴上，一般都是从<code>inorder</code>中访问元素并创建节点，将<code>preorder</code>或者<code>postorder</code>作为迭代顺序的依据。<code>inorder</code>的根节点是在中间的，不论对于整个树还是对任一节点为根节点的suntree</p>\n<h2 id=\"from-inorder-and-postorder\">From inorder and postorder<a href=\"#from-inorder-and-postorder\" title=\"From inorder and postorder\"></a></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, inorder, postorder)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type inorder: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type postorder: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder:</span><br><span class=\"line\">            idx = inorder.index(postorder.pop())</span><br><span class=\"line\">            root = TreeNode(inorder[idx])</span><br><span class=\"line\">            root.right = self.buildTree(inorder[idx+<span class=\"number\">1</span>:], postorder)</span><br><span class=\"line\">            root.left = self.buildTree(inorder[:idx], postorder)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure><h2 id=\"from-inorder-and-preorder\">From inorder and preorder<a href=\"#from-inorder-and-preorder\" title=\"From inorder and preorder\"></a></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">buildTree</span><span class=\"params\">(self, preorder, inorder)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type preorder: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :type inorder: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> inorder:</span><br><span class=\"line\">            idx = inorder.index(preorder.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\">            root = TreeNode(inorder[idx])</span><br><span class=\"line\">            root.left = self.buildTree(preorder, inorder[:idx])</span><br><span class=\"line\">            root.right = self.buildTree(preorder, inorder[idx+<span class=\"number\">1</span>:])</span><br><span class=\"line\">            <span class=\"keyword\">return</span> root</span><br></pre></td></tr></table></figure>","prev":{"title":"Stack and DFS","link":"post/Stack"},"next":{"title":"Binary Tree（1）","link":"post/Tree-01"},"plink":"https://magi003769.github.io/post/Tree-02/","toc":[{"id":"find-path","title":"Find Path","index":"1"},{"id":"depth-of-tree","title":"Depth of Tree","index":"2","children":[{"id":"maximum-depth-of-binary-tree","title":"Maximum Depth of Binary Tree","index":"2.1"},{"id":"diameter-of-binary-tree","title":"Diameter of Binary Tree","index":"2.2"}]},{"id":"construct-tree","title":"Construct Tree","index":"3","children":[{"id":"from-inorder-and-postorder","title":"From inorder and postorder","index":"3.1"},{"id":"from-inorder-and-preorder","title":"From inorder and preorder","index":"3.2"}]}]}