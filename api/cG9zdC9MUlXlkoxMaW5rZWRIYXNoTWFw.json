{"title":"LRU Cache和LinkedHashMap","date":"2020-05-17T07:00:00.000Z","date_formatted":{"ll":"May 17, 2020","L":"05/17/2020","MM-DD":"05-17"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1509475826633-fed577a2c71b.jpeg","link":"post/LRU和LinkedHashMap","tags":["LRU","LeetCode","LinkedHashMap"],"categories":["算法数据结构"],"updated":"2020-05-18T22:23:55.773Z","content":"<p>讲一下LRU Cache和LinkedHashMap。很多公司在面试的时候会考到这个，这个也是刷题的时候一直没仔细研究的，这里就专门拉出来一个post梳理一下这个。</p>\n<a id=\"more\"></a><h1 id=\"lru-cache\">LRU Cache<a href=\"#lru-cache\" title=\"LRU Cache\"></a></h1><p>LRU指的是Least Recent Used Cache，即<strong>最近最少使用</strong>。关于这个概念，要先从缓存讲起。当计算机想要获取一些数据使用时，需要在硬盘的存储空间里查找读取。这是一个比较费时的工作，如果我们能把<strong>一段时间经常用到</strong>的数据存储在更便于读取的地方，那么就会使计算机的运行更快。这就是缓存。打个比方，我们想打电话的时候，会有常用联系人，我们甚至自己就可以记住，不需要查阅通讯录，可以做到快速调用。</p>\n<p><img src=\"https://pic2.zhimg.com/v2-dddb62fbf70d71f1430c2619b46840a5_b.jpg\" class=\"φcy\" alt=\"缓存\"></p>\n<p>但是我们的记忆是有限的，有些人会联系愈发频繁，有些人则会渐渐疏远慢慢忘记。所以，和人的记忆一样，缓存的容量也是有限的：当需要读取缓存中没有的数据时，就必定要淘汰一些缓存的数据来给新的数据腾出空间。比较简单直接的策略就是，删去那些CPU不经常使用的数据。因此，LRU Cache的策略就是把最近最少使用的数据先淘汰掉。总结一下，LRU Cache有以下几个特点：</p>\n<ul><li>容量固定，需要按规则淘汰</li>\n<li>快速访问（<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.745ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2043 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">O(1)</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4F\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4F\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"763\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-31\" x=\"1153\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-29\" x=\"1653\" y=\"0\"></use>\n</g>\n</svg>时间复杂度）</li>\n</ul><p>要实现这个功能我们需要使用到比较特殊的数据结构<code>LinkedHashMap</code>，它是一种有序的哈希表，在Java中有实现，而Python中则是<code>OrderedDict</code>。</p>\n<h1 id=\"linkedhashmap\">LinkedHashMap<a href=\"#linkedhashmap\" title=\"LinkedHashMap\"></a></h1><p>以Java的<code>LinkedHashMap</code>为例讲一下相关知识。普通的<code>HashMap</code>只保证快速的查找，但是并不保证其内部的<code>Entry</code>是顺序的。<code>LinkedHashMap</code>则保证遍历时<code>Entry</code>按照一定顺序：<strong>插入顺序（insertion order）或者访问顺序（acess order）。</strong>使用后者，<code>LinkedHashMap</code>就可以直接实现LRU Cache，后面会有具体的代码例子。</p>\n<p>普通<code>HashMap</code>的<code>Entry</code>只包含<code>key</code>、<code>value</code>以及<code>next</code>来应对可能发生的冲突。而<code>LinkedHashMap</code>的<code>Entry</code>则包含了更多的内容来维护一个双向链表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">         K key;</span><br><span class=\"line\">         V value;</span><br><span class=\"line\">         Entry&lt;K,V&gt; next;</span><br><span class=\"line\">         Entry&lt;K,V&gt; before, after;</span><br><span class=\"line\">            </span><br><span class=\"line\">         <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Entry</span><span class=\"params\">(K key, V value, Entry&lt;K,V&gt; next)</span></span>&#123;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.key = key;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">             <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>before</code>和<code>after</code>两个成员变量，就是用来构成这个双向链表的。这个双向链表保证了迭代时<code>Entry</code>有一定的顺序。在使用时，不论是添加还是访问，都会根据初始化要求顺序的不同来维护这个链表。下面这张图简单的说明了<code>LinkedHashMap</code>的内部构造。</p>\n<p><img src=\"https://lh4.googleusercontent.com/5M89iub9wNrKR-jmctcmLtGIHiy0lbqL5Oz18AvQyuHdFXGDC4qKgCVZO73WPujj3qqquh_WXlKp7zem4vCfEynJzcN-t0a_wa_mSxDO62G2C-YgEvUhQRBdXdWvpBIhDDM0BxE\" class=\"φcy\" alt=\"LinkedHashMap实现\"></p>\n<p>对于初始化<code>LinkedHashMap</code>，它有几个不同参数的构造器，这里说一下LRU会用到的，也是参数最多的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LinkedHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">float</span> loadFactor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                     <span class=\"keyword\">boolean</span> accessOrder)</span></span></span><br></pre></td></tr></table></figure><p>注意到<code>accessOrder</code>这个参数，一般不涉及这个参数设置的构造器会直接按照insertion oder来维护链表，只有在<code>acessOrder</code>被设定为<code>true</code>的时候，<code>LinkedHashMap</code>内部才会按照访问顺序来维护这个链表。</p>\n<h2 id=\"按访问顺序维护链表\">按访问顺序维护链表<a href=\"#按访问顺序维护链表\" title=\"按访问顺序维护链表\"></a></h2><p>理论上我们只要直接使用<code>LinkedHashMap</code>就可以实现LRU Cache的功能了。但是面试的时候把后才能回被问得更深入，问能不能自己实现一个。这时候就需要直到怎么实现这个按访问顺序维护的链表，而且要保证哈希表的<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.745ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2043 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">O(1)</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4F\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4F\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"763\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-31\" x=\"1153\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-29\" x=\"1653\" y=\"0\"></use>\n</g>\n</svg>查找。</p>\n<p>基本的做法可以参考下面这张图：建立一个普通的无序<code>HashMap</code>，<code>key</code>均映射到双向链表中的一个节点（因为Java里面觉得部分都是引用类型，实际上哈希表里面<code>Entry.getValue()</code>得到的是节点的引用）。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Java/naive_LRU.png\" class=\"φcy\" alt=\"naive-LRU-Cache\"></p>\n<p>假设这里规定链表尾部是最新访问的最新访问或者添加的节点。那么，在我们访问过某个节点之后，需要将它移动到链表尾部，每次当容量满了的时候，都删去头部的节点来腾出空间。</p>\n<p>下面代的代码片段，是上面这种设计的代码实现。没有实现双向链表类，而是只定义了节点作为内部类，其他链表操作都作为私有函数，帮助<code>get()</code>和<code>put()</code>这两个方法维护链表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DLinkedNode</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> key;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">        DLinkedNode pre;</span><br><span class=\"line\">        DLinkedNode next;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DLinkedNode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            key = <span class=\"number\">0</span>;</span><br><span class=\"line\">            value = <span class=\"number\">0</span>;</span><br><span class=\"line\">            pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">DLinkedNode</span><span class=\"params\">(<span class=\"keyword\">int</span> k, <span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">            key = k;</span><br><span class=\"line\">            value = val;</span><br><span class=\"line\">            pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表中添加新的节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        node.next = tail;</span><br><span class=\"line\">        node.pre = tail.pre;</span><br><span class=\"line\">        tail.pre.next = node;</span><br><span class=\"line\">        tail.pre = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在链表中删去节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">removeNode</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode pre = node.pre;</span><br><span class=\"line\">        DLinkedNode next = node.next;</span><br><span class=\"line\">        pre.next = next;</span><br><span class=\"line\">        next.pre = pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 将某一节点移动到链表尾部</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">moveToTail</span><span class=\"params\">(DLinkedNode node)</span> </span>&#123;</span><br><span class=\"line\">        removeNode(node);</span><br><span class=\"line\">        addNode(node);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 移除头部节点并返回该节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> DLinkedNode <span class=\"title\">popTop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode top = head.next;</span><br><span class=\"line\">        removeNode(top);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> top;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> capacity;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HashMap&lt;Integer, DLinkedNode&gt; cache;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DLinkedNode head, tail;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> cap)</span> </span>&#123;</span><br><span class=\"line\">        capacity = cap;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        head.pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        tail = <span class=\"keyword\">new</span> DLinkedNode();</span><br><span class=\"line\">        tail.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head.next = tail;</span><br><span class=\"line\">        tail.pre = head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        DLinkedNode node = cache.get(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        moveToTail(node); <span class=\"comment\">// 因为访问过该节点，将其移到链表尾部</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cache.containsKey(key)) &#123; </span><br><span class=\"line\">            <span class=\"comment\">// 如果是已经存在的key，将对应的节点放到链表尾部</span></span><br><span class=\"line\">            DLinkedNode node = cache.get(key);</span><br><span class=\"line\">            node.value = value;</span><br><span class=\"line\">            moveToTail(node);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        DLinkedNode node = <span class=\"keyword\">new</span> DLinkedNode(key, value);</span><br><span class=\"line\">        cache.put(key, node);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(size == capacity) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果cache的容量已经满了，就删去链表头部的节点，再加入新的节点</span></span><br><span class=\"line\">            DLinkedNode top = popTop();</span><br><span class=\"line\">            cache.remove(top.key);</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addNode(node);</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"不同map的比较\">不同Map的比较<a href=\"#不同map的比较\" title=\"不同Map的比较\"></a></h2><p>![不同哈希表的比较](/Users/wangruihao/Library/Application Support/typora-user-images/image-20200518152347608.png “|block”)</p>\n<h1 id=\"相关的问题\">相关的问题<a href=\"#相关的问题\" title=\"相关的问题\"></a></h1><p>这里介绍两个用到<code>LinkedHashMap</code>或者链表和哈希表组合的例题，都是LeetCode上刷到的。</p>\n<h2 id=\"lru-cache-1\">LRU Cache<a href=\"#lru-cache-1\" title=\"LRU Cache\"></a></h2><p><a href=\"https://leetcode.com/problems/lru-cache/\" target=\"_blank\"> LRU Cache</a>，线面讲链表维护的地方已经写了一个基础的实现，这里给一个简单的。直接让<code>LRUCache</code>继承<code>LinkedHashMap</code>，并将<code>accessOrder</code>设置为<code>true</code>，就可以直接实现功能。需要注意的就是初始化的构造器，还有<code>get</code>可能找不到<code>key</code>的处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LRUCache</span> <span class=\"keyword\">extends</span> <span class=\"title\">LinkedHashMap</span>&lt;<span class=\"title\">Integer</span>, <span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAX_ENTRIES;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LRUCache</span><span class=\"params\">(<span class=\"keyword\">int</span> capacity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"number\">2</span>*capacity, <span class=\"number\">1</span>, <span class=\"keyword\">true</span>); <span class=\"comment\">// 注意这里的参数</span></span><br><span class=\"line\">        MAX_ENTRIES = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.get(key) != <span class=\"keyword\">null</span> ? <span class=\"keyword\">super</span>.get(key) : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeEldestEntry</span><span class=\"params\">(Map.Entry eldest)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size() &gt; MAX_ENTRIES;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(key);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.put(key,value);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure><h2 id=\"fist-unique-number-in-data-stream\">Fist Unique Number in Data Stream<a href=\"#fist-unique-number-in-data-stream\" title=\"Fist Unique Number in Data Stream\"></a></h2><p><a href=\"https://leetcode.com/discuss/interview-question/algorithms/124822/bloomberg-interview-question-find-first-unique-integer-in-a-stream\" target=\"_blank\">Boolmberg - First Unique Number in Data Stream</a>，这是个被锁的题目，似乎是去年年底Bloomberg的OA题目。也挺典型的，<code>HashMap</code>记录数字出现的次数，同时又一个<code>LinkedList</code>作为队列保证遍历数字时的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FirstUnique</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> HashMap&lt;Integer, Integer&gt; counts;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LinkedList&lt;Integer&gt; queue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FirstUnique</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        counts = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">                counts.put(num, counts.get(num)+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                counts.put(num, <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(counts.get(num) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                queue.add(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">showFirstUnique</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(queue.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(counts.get(queue.peek()) &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">                queue.remove();</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> queue.peek();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(counts.containsKey(value)) &#123;</span><br><span class=\"line\">            counts.put(value, counts.get(value)+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            queue.add(value);</span><br><span class=\"line\">            counts.put(value, <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://stackoverflow.com/questions/2889777/difference-between-hashmap-linkedhashmap-and-treemap\" target=\"_blank\">Stack Overflow - Comparison of Maps</a></li>\n<li><a href=\"https://medium.com/@krishankantsinghal/my-first-blog-on-medium-583159139237\" target=\"_blank\">Implement LRU Cache </a></li>\n<li><a href=\"https://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.html\" target=\"_blank\">LinkedHashMap实现原理</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/76553221\" target=\"_blank\">面试必备之LRU Cache</a></li>\n<li><a href=\"https://www.javamadesoeasy.com/2015/02/linkedhashmap-custom-implementation.html\" target=\"_blank\">How LinkedHashMap works</a></li>\n</ul>","prev":{"title":"强行置顶：关于这个博客 About this blog","link":"post/关于这个博客"},"next":{"title":"Java的Concurrent集合和Atomic类","link":"post/Java的Concurrent集合和Atomic类"},"plink":"https://magi003769.github.io/post/LRU和LinkedHashMap/","toc":[{"id":"lru-cache","title":"LRU Cache","index":"1"},{"id":"linkedhashmap","title":"LinkedHashMap","index":"2","children":[{"id":"按访问顺序维护链表","title":"按访问顺序维护链表","index":"2.1"},{"id":"不同map的比较","title":"不同Map的比较","index":"2.2"}]},{"id":"相关的问题","title":"相关的问题","index":"3","children":[{"id":"lru-cache-1","title":"LRU Cache","index":"3.1"},{"id":"fist-unique-number-in-data-stream","title":"Fist Unique Number in Data Stream","index":"3.2"}]},{"id":"references","title":"References","index":"4"}]}