{"title":"Java的Concurrent集合和Atomic类","date":"2020-05-16T07:00:00.000Z","date_formatted":{"ll":"May 16, 2020","L":"05/16/2020","MM-DD":"05-16"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1472457897821-70d3819a0e24.jpeg","link":"post/Java的Concurrent集合和Atomic类","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-16T23:26:17.432Z","content":"<p>之前几篇post已经介绍了Java中如何实现线程安全的类，比如任务管理器就实现了一个线程安全的<code>BlockingQueue</code>，它允许多线程的读写操作。这里介绍一下Java标准库提供的线程安全的并发集合类，他们都在<code>java.util.concurrent</code>中。另外，<code>java.util.concurrent.atomic</code>还提供了一组原子操作的封装类。</p>\n<a id=\"more\"></a><h1 id=\"并发集合\">并发集合<a href=\"#并发集合\" title=\"并发集合\"></a></h1><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>接口</th><th>非线程安全</th><th>线程安全</th></tr>\n</thead><tbody><tr>\n<td>List</td><td>ArrayList</td><td>CopyOnWriteArrayList</td></tr>\n<tr>\n<td>Map</td><td>HashMap</td><td>ConcurrentHashMap</td></tr>\n<tr>\n<td>Set</td><td>Set</td><td>CopyOnWriteArraySet</td></tr>\n<tr>\n<td>Queue</td><td>ArrayDequeue / LinkedList</td><td>ArrayBlockingQueue / LinkedBlockingQueue</td></tr>\n<tr>\n<td>Dequeue</td><td>ArrayDequeue / LinkedList</td><td>LinkedBlockingDeque</td></tr>\n</tbody></table></div></div><p>上面的表总结了<code>java.util.concurrent</code>提供的并发集合。因为多线程逻辑都是在类内部实现的，那么在使用这些集合的时候可以像普通集合一样，在不同的线程中直接调用几何的读写方法就可以直接使用了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map unsafeMap = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">Map threadSafeMap = Collections.synchronizedMap(unsafeMap);</span><br></pre></td></tr></table></figure><p><code>java.util.Collections</code>还提供了一个旧的线程安全转换器，可以将普通的集合转化成线程安全的集合。它实际上使用<code>synchronized</code>给集合的读写方法加锁，这样获得的线程安全集合比<code>java.util.concurrent</code>提供的要低很多。</p>\n<h1 id=\"原子类\">原子类<a href=\"#原子类\" title=\"原子类\"></a></h1><p><code>java.util.concurrent</code>除了提供底层锁、并发集合之外，其中的<code>java.util.concurrent.atomic</code>还提供了一组原子操作的封装类。</p>\n<p>以<code>AtomicInteger</code>为例，他们提供的主要操作有：</p>\n<ul><li>增加指定的值然后返回最新值 - <code>int addAndGet(int delta)</code></li>\n<li>自增1并返回最新值 - <code>int incrementAndGet()</code></li>\n<li>获取当前值 - <code>int get()</code></li>\n<li>用CAS方式进行设置（修改）- <code>int compareAndSet(int expect, int update)</code></li>\n</ul><h2 id=\"cas的概念\">CAS的概念<a href=\"#cas的概念\" title=\"CAS的概念\"></a></h2><p>注意这里我们引入了一个新的名词<code>CAS</code>，意思是：Compare and Set。它主要分为两步：</p>\n<ol><li>获取共享变量的旧值，并执行一些操作得到新的值；</li>\n<li>对获取的旧值进行比较，如果在这个过程中没有现成对变量进行修改，即可修改；</li>\n</ol><p>如果我们自己利用CAS机制实现<code>incrementAndGet</code>方法，大概就是下面这么个感觉</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">incrementAndGet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> prev, next;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        prev = get();</span><br><span class=\"line\">        next = prev + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( ! compareAndSet(prev, next));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，好像这个过程压根儿就没上锁，所以<code>Atomic</code>类实际上是一个Lock-free的实现。再联想到之前的乐观锁：</p>\n<ul><li>先尝试<code>tryOptimisticRead()</code>；</li>\n<li>在使用<code>validate(stamp)</code>验证过程中是否有写入，如果验证是失败再获取悲观读锁；</li>\n</ul><p>这两个是不是很像？<strong>所以CAS机制实际上是乐观锁的实现基础之一。</strong>简单了解一下CAS可能有的缺点：</p>\n<ul><li>ABA问题：如果A线程获取之后，B线程获取然后又被改了回去，A线程再执行CAS。如果修改的是引用类型，那么就会出很大问题。(<strong>引入版本号机制解决：</strong>每次修改都更新版本号，并比较版本号，不直接比较变量的值)</li>\n<li>只对单个变量有作用，涉及多个变量就不行了</li>\n<li>自旋CAS如果一直不成功，开销大。</li>\n</ul><h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><ul><li>并发集合线程安全，封装好的线程逻辑可以简化代码；</li>\n<li>CAS是乐观锁（lock-free线程安全）的基础机制之一，要配合版本号使用（ABA）问题；</li>\n<li>原子操作实现了无锁的线程安全；</li>\n<li>适用于计数器，累加器等</li>\n</ul><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n<li>Java并发编程的艺术</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/71156910\" target=\"_blank\">Java的各种锁</a></li>\n<li><a href=\"https://juejin.im/post/5c87afa06fb9a049f1550b04\" target=\"_blank\">CAS原理分析及ABA问题详解</a></li>\n</ul>","prev":{"title":"LRU Cache和LinkedHashMap","link":"post/LRU和LinkedHashMap"},"next":{"title":"Java多线程的几种Lock","link":"post/Java多线程使用ReentrantLock等"},"plink":"https://magi003769.github.io/post/Java的Concurrent集合和Atomic类/","toc":[{"id":"并发集合","title":"并发集合","index":"1"},{"id":"原子类","title":"原子类","index":"2","children":[{"id":"cas的概念","title":"CAS的概念","index":"2.1"}]},{"id":"summary","title":"Summary","index":"3"},{"id":"references","title":"References","index":"4"}]}