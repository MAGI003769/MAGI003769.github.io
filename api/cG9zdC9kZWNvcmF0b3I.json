{"title":"Python中的装饰器与类中的property","date":"2018-06-30T07:00:00.000Z","date_formatted":{"ll":"Jun 30, 2018","L":"06/30/2018","MM-DD":"06-30"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/post-bg.jpg","link":"post/decorator","tags":["Decorator","Python","基本概念","面试"],"categories":["Python"],"updated":"2019-05-07T06:10:06.000Z","content":"<p>原来读 python 代码的时候，经常遇到 <code>@</code> 这个符号却并不知道是个啥意思。它经常出现在某一个类的函数定义前。这就是 python 的一个语法糖 —— 装饰器（Decorator）。考虑到模块化的设计，<strong>装饰器帮助我们在不改变函数定义的情况下，增加需要的功能</strong>，比如输出日志，性能测试，事务处理、缓存、权限校验等。</p>\n<a id=\"more\"></a><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">\t@functools.wraps(func)</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*arg, **kwargs)</span>:</span></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'\\ncall %s()'</span> % func.__name__)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> func(*arg, **kwargs)</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">slogan</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\tprint(<span class=\"string\">'Don\\'t stop learning'</span>)</span><br></pre></td></tr></table></figure><p>装饰器本质上是能够返回一个函数的高阶函数。上面是一个装饰器的实现，是一个二层嵌套结构，基本的功能是在调用函数的时候产生日志。在定义函数 <code>slogan()</code> 时，相当于执行了语句 <code>slogan=log(slogan)</code>。<strong><code>log()</code>  是一个装饰器，返回一个函数，所以最原始的函数 <code>slogan()</code> 依然存在，而现在同名的 <code>slogan</code> 变量则指向一个经过 <code>log()</code> 处理的新函数。</strong> 所以在主程序中调用 <code>slogan()</code> 将会执行新的函数，即 <code>log()</code> 中返回的 <code>wrapper()</code> 函数。</p>\n<p>如果我们需要给装饰器本身传入参数，在定义时就需要在 <code>wrapper()</code> 外在封装一层，原先的最外层就用来区别装饰器的名称和传参。这样，需要传参的装饰器就是一个三层嵌套结构。定义函数时相当于执行了 <code>slogan = log2(&#39;execute&#39;)(slogan)</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log2</span><span class=\"params\">(text)</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@functools.wraps(func)</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*arg, **kwargs)</span>:</span></span><br><span class=\"line\">\t\t\tprint(<span class=\"string\">'\\n%s %s()'</span> % (text, func.__name__))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> func(*arg, **kwargs)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log2('execute')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">slogan</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">\tprint(<span class=\"string\">'Don\\'t stop learning'</span>)</span><br></pre></td></tr></table></figure><p>上面的两个装饰器有一个值得注意的地方：<code>@functools.wraps(func)</code>。它是为了解决关于函数名统一的问题。在 python 中，函数作为对象，也有一个属性 <code>__name__</code>。上面我们也讨论了，装饰器是返回了一个函数，那么他最终返回的就是嵌套在最内层的 <code>wrapper()</code>。因此，在没有 <code>@functools.wraps(func)</code> 这个指令的情况下，我们获取函数名时 <code>slogan.__name__</code> 会输出 <code>&#39;wrapper&#39;</code>，而不是 <code>&#39;slogan&#39;</code>。<code>@functools.wraps(func)</code> 相当于在装饰器内执行 <code>wrapper.__name__=func.__name__</code>。<strong>这一命令是使用在 wrapper函数之前的。</strong></p>\n<p><strong>小练习：如何定义一个在调用函数前后都输出日志的装饰器？</strong></p>\n<p>只要在最内层的 <code>wrapper()</code> 中调用被修饰的函数，将其赋值给一个变量。这样就在调用的同时又可以返回该函数。只要在调用前后进行日志输出即可。单纯地将调用后的日志输出设定在wrapper外，decorator之内是不行的。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''Exercise'''</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Following funciton is WRONG</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log3</span><span class=\"params\">(text=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@functools.wraps(func)</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*arg, **kwargs)</span>:</span></span><br><span class=\"line\">\t\t\tprint(<span class=\"string\">'\\nBegin call: %s%s'</span> % (text, func.__name__))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> call</span><br><span class=\"line\">         print(<span class=\"string\">'End call: %s%s'</span> % (text, func.__name__))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Following funciton is RIGHT</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log3</span><span class=\"params\">(text=<span class=\"string\">''</span>)</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">\t\t@functools.wraps(func)</span></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*arg, **kwargs)</span>:</span></span><br><span class=\"line\">\t\t\tprint(<span class=\"string\">'\\nBegin call: %s%s'</span> % (text, func.__name__))</span><br><span class=\"line\">\t\t\tcall = func(*arg, **kwargs)</span><br><span class=\"line\">\t\t\tprint(<span class=\"string\">'End call: %s%s'</span> % (text, func.__name__))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> call</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> decorator</span><br></pre></td></tr></table></figure><h1 id=\"一个-python-内置的装饰器：property\">一个 Python 内置的装饰器：<code>@property</code><a href=\"#一个-python-内置的装饰器：property\" title=\"一个 Python 内置的装饰器：@property\"></a></h1><p>这里介绍一个修饰器在 Python 的一个应用：<code>@property</code>。它非常广泛的应用在 OOP 中。通常情况下定义一个类，我们需要如下的设计：<code>get_score()</code>来获取成绩，<code>set_score()</code> 来设定、修改成绩，这样就可以在设置时检查成绩是否合法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._score</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</span><br><span class=\"line\">        self._score = value</span><br></pre></td></tr></table></figure><p>但是为了程序的简单易用性，我们想要使用类似于属性的简单方式来访问类的变量，同时又可以对参数的合法性进行检查。于是 Python 就为我们提供了一个内置的装饰器 <code>@property</code> 来达到这个目的。将一个同名的函数定义时加上 <code>@property</code> 就可以了。与此同时，它有自动生成了另一个装饰器 <code>@score.setter</code>，用来把一个 setter 变成属性变量，于是就产生了一个可以设置检查条件的简单方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">\t@property</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self.__score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">\t@score.setter</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self, value)</span>:</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be integer!'</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must between 0 ~ 100'</span>)</span><br><span class=\"line\">\t\tself.__score = value</span><br></pre></td></tr></table></figure><p>一点想法：关于私有变量。C++ 中的私有变量是不能直接访问的，需要通过特定的方法方法才能访问。上面这样的设计就意味着设计了一个访问方法。那么 python 中又是如何保证私有变量不被外部非友元访问的呢？</p>\n<h1 id=\"reference\">Reference<a href=\"#reference\" title=\"Reference\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386819879946007bbf6ad052463ab18034f0254bf355000\" target=\"_blank\">廖雪峰 - 装饰器</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820062641f3bcc60a4b164f8d91df476445697b9e000\" target=\"_blank\">廖雪峰 - @property 使用</a></li>\n<li><a href=\"https://www.programiz.com/python-programming/property\" target=\"_blank\">python programming - property</a></li>\n</ul>","prev":{"title":"机器学习模型——朴素贝叶斯法","link":"post/朴素贝叶斯"},"next":{"title":"机器学习模型——逻辑斯谛回归","link":"post/逻辑斯谛"},"plink":"https://magi003769.github.io/post/decorator/","toc":[{"id":"一个-python-内置的装饰器：property","title":"一个 Python 内置的装饰器：@property","index":"1"},{"id":"reference","title":"Reference","index":"2"}]}