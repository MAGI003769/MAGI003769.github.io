{"title":"Java线程的同步与锁","date":"2020-05-13T07:00:00.000Z","date_formatted":{"ll":"May 13, 2020","L":"05/13/2020","MM-DD":"05-13"},"link":"post/Java线程的同步与锁","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-14T06:47:05.142Z","content":"<p>前面两篇讲了Java多线程相关的概念以及如何创建线程，这中间讨论到了共享变量的同步问题，并引入了<code>volatile</code>关键词。这里我们进一步讨论线程之间的同步，引入锁的概念，并讲<code>volatile</code>和<code>synchronized</code>进行比较。</p>\n<a id=\"more\"></a><h1 id=\"线程的同步\">线程的同步<a href=\"#线程的同步\" title=\"线程的同步\"></a></h1><h2 id=\"多线程带来的问题\">多线程带来的问题<a href=\"#多线程带来的问题\" title=\"多线程带来的问题\"></a></h2><p><strong>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。</strong>因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>\n<p>下面的代码片段逻辑很简单，使用两个线程修改同一个变量值，<code>AddThread</code>负责增、<code>DecThread</code>负责减。<code>main</code>线程的逻辑就是单纯的启动两个线程（执行先后受OS调度，不受我们控制），预期的输出结果0，因为两个线程执行的加减操作一样多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> AddThread();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> dec = <span class=\"keyword\">new</span> DecThread();</span><br><span class=\"line\">        add.start();</span><br><span class=\"line\">        dec.start();</span><br><span class=\"line\">        add.join();</span><br><span class=\"line\">        dec.join();</span><br><span class=\"line\">        System.out.println(Counter.count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object lock = <span class=\"keyword\">new</span> Object(); <span class=\"comment\">// 创建一个对象作为锁</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Counter.count += 1;</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123; <span class=\"comment\">// critical section, 获取锁</span></span><br><span class=\"line\">                Counter.count += <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DecThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// Counter.count -= 1;</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(Counter.lock) &#123; <span class=\"comment\">// critial section, 获取锁</span></span><br><span class=\"line\">                Counter.count -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"comment\">// 释放锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果我们忽略锁的部分，值考虑简单的操作（注释部分），那么实际的输出就不一定为0了。因为<code>n = n + 1</code>实际上有三个指令组成</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ILOAD</span><br><span class=\"line\">IADD</span><br><span class=\"line\">ISTORE</span><br></pre></td></tr></table></figure><p>由于线程的调度我们并不确定，有可能会出现下图中左侧的情况：两个线程读取到了相同的值然后操作。最终应该是102的结果，变成了101。因此，为了保证线程操作的逻辑正确，<strong>对共享变量的操作必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待。(原子性的定义)</strong></p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Java/counter%E5%8A%A0%E9%94%81.png\" class=\"φcy\" alt=\"加锁与不加锁\"></p>\n<p>通过<strong>加锁和解锁</strong>，我们可以保证三个指令在某一线程下连续执行，这期间不会有其他线程介入。不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为<strong>临界区（Critical Section）</strong>，<strong>任何时候临界区最多只有一个线程能执行。</strong></p>\n<p>于是我们使用<code>synchronized</code>关键字来使得临界区的代码保持原子性，它保证了代码块在任意时刻最多只有一个线程能执行。</p>\n<h2 id=\"synchronized与锁\"><code>synchronized</code>与锁<a href=\"#synchronized与锁\" title=\"synchronized与锁\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">synchronized</span>(Counter.lock) &#123; <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// 释放锁</span></span><br></pre></td></tr></table></figure><p><code>synchronized</code>所覆盖的临界区，有一个<code>Counter.lock</code>实例作为<strong>锁</strong>，必须先获得锁才能执行临界区的代码。临界区开始时会获取锁，结束时释放。</p>\n<p>使用<code>synchronized</code>可以解决多线程的共享变量同步问题，但是，同样也带来了性能上的损失：(1) 使用同一个对象作为锁的<code>synchronized</code>代码块不能并发执行，(2) 获取锁和释放锁都需要消耗一定时间。这样执行效率就有所降低。</p>\n<p>概括一下<code>synchronized</code>和锁的使用：</p>\n<ul><li>找出修改共享变量的代码块</li>\n<li>选择<strong>同一个</strong>实例作为锁</li>\n<li>用<code>sychronized{...}</code></li>\n</ul><p>使用<code>synchronized</code>不需要考虑异常抛出，锁一样会正确释放。</p>\n<h2 id=\"不需要同步的操作\">不需要同步的操作<a href=\"#不需要同步的操作\" title=\"不需要同步的操作\"></a></h2><p>JVM规定了一下集中原子操作：</p>\n<ul><li>基本类型的赋值（<code>long</code>和<code>double</code>除外）</li>\n<li>引用类型的赋值</li>\n</ul><p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p>\n<p>另外，只有<strong>单独</strong>的赋值语句不需要同步，而多个连续的赋值语句就有可能需要。考虑同步时，也仅考虑涉及共享变量的部分代码，而不考虑只操作线程私有局部变量的代码。</p>\n<h1 id=\"sychronized与volatile的比较\"><code>sychronized</code>与<code>volatile</code>的比较<a href=\"#sychronized与volatile的比较\" title=\"sychronized与volatile的比较\"></a></h1><p>上一篇里面提到的<code>volatile</code>关键字似乎也有一点同步的意味，这里就座以下两个关键字的比较：</p>\n<ul><li><code>volatile</code>关键字是轻量级的同步实现，他只能是的变量同步；而<code>synchronized</code>则可以用于修饰方法和指定的代码块</li>\n<li>性能上来讲<code>volatile</code>没有涉及锁的问题，因此性能更好；JavaSE1.6之后对<code>synchronized</code>进行了优化，实际开发中，使用<code>synchronized</code>的场景还是更多一些</li>\n<li>多线程访问<code>volatile</code>修饰的变量不存在阻塞；<code>synchronized</code>的使用可能带来阻塞</li>\n<li><code>volatile</code>保证数据的可见性，但是不保证数据的原子性；<code>synchronized</code>两者都可以保证</li>\n<li><code>volatile</code>主要用于解决变量在各线程之间的可见性；<code>synchronized</code>主要用于解决多线程访问变量的同步性</li>\n</ul><h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><ul><li>多线程同时读写共享变量是，相关代码需要用<code>sychronized</code>同步</li>\n<li>同步的本质是给对象加锁，获取到锁之后才能继续执行临界区中的代码</li>\n<li>加锁对象必须是同一实例</li>\n<li>JVM定义的单步原子操作不需要同步</li>\n</ul><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n<li>Java并发编程的艺术</li>\n</ul>","prev":{"title":"强行置顶：关于这个博客 About this blog","link":"post/关于这个博客"},"next":{"title":"Java线程的创建与状态","link":"post/Java线程的创建与状态"},"plink":"https://magi003769.github.io/post/Java线程的同步与锁/","toc":[{"id":"线程的同步","title":"线程的同步","index":"1","children":[{"id":"多线程带来的问题","title":"多线程带来的问题","index":"1.1"},{"id":"synchronized与锁","title":"synchronized与锁","index":"1.2"},{"id":"不需要同步的操作","title":"不需要同步的操作","index":"1.3"}]},{"id":"sychronized与volatile的比较","title":"sychronized与volatile的比较","index":"2"},{"id":"summary","title":"Summary","index":"3"},{"id":"references","title":"References","index":"4"}]}