{"title":"Java面向对象","date":"2019-08-04T07:00:00.000Z","date_formatted":{"ll":"Aug 4, 2019","L":"08/04/2019","MM-DD":"08-04"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1483446227769-9137a8af8667.jpeg","link":"post/接口和抽象类","tags":["Java","抽象类","接口"],"categories":["Java"],"updated":"2020-05-24T09:49:40.306Z","content":"<p>还是Java相关的基础知识，讲一下Java的OO、抽象类和接口的概念。这两个概念非常相近，都属于OO的范畴，都关系到多态，很容易搞混。</p>\n<a id=\"more\"></a><h1 id=\"java面向对象编程的三大特性\">Java面向对象编程的三大特性<a href=\"#java面向对象编程的三大特性\" title=\"Java面向对象编程的三大特性\"></a></h1><ul><li><strong>封装</strong>：指将对象的属性私有化，只在需要时提供一些外部访问属性的方法</li>\n<li><strong>继承</strong>：指使用已存在的类定义作为基础创建新的类。新的类可以定一新增属性和方法，可以使用父类的功能，但不能选择性继承</li>\n<li><strong>多态</strong>：指程序运行中定义的引用变量所指向的聚义类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。即一个引用变量具体指向的实例以及方法调用，究竟属于哪一个类，必须在程序运行期间决定。</li>\n</ul><h1 id=\"重载与重写\">重载与重写<a href=\"#重载与重写\" title=\"重载与重写\"></a></h1><ul><li><strong>重载</strong>：发生在<strong>同一个类内部</strong>，有<strong>相同名称</strong>的方法，其参数类型、数量、顺序、返回值或返回修饰符等可以不同</li>\n<li><strong>重写（覆写）</strong>：指子类对父类允许访问的方法的实现过程中进行重新编写。方法名称以及参数等都要求一致</li>\n</ul><h1 id=\"抽象类\">抽象类<a href=\"#抽象类\" title=\"抽象类\"></a></h1><p>由于多态的存在，子类都可以覆写父类的方法。很多时候父类的方法本身是不需要任何功能够实现的，这些方法的意义就是定义方法签名，以及供子类覆写。这样就可以把这个父类做成抽象类，方法做成抽象方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>abstract</code>关键字用来使被修饰的类和对象变成抽象类和抽象方法。抽象类被设计为用于被继承的类，且无法实例化。他可以强迫从它这里派生的子类实现其定义的抽象方法。同时抽象类也可以定义非抽象方法。</p>\n<p>子类使用<code>extends</code>关键字表示继承关系，且只能继承唯一的父类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"接口\">接口<a href=\"#接口\" title=\"接口\"></a></h1><p>抽象类本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现。如果抽象类的所有方法都是抽象方法，就可以把它改写成一个接口。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以说接口是比抽象类更抽象的存在，同样是用于规范高级类的行为规范。某一个类想要继承接口的话，要使用<code>implements</code>关键字，并将抽象方法都做具体的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"keyword\">this</span>.name + <span class=\"string\">\" run\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>与抽象类不同的是，一个派生类实际上可以继承不止一个接口。Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span>, <span class=\"title\">Hello</span> </span>&#123; <span class=\"comment\">// 实现了两个interface</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"举个栗子\">举个栗子<a href=\"#举个栗子\" title=\"举个栗子\"></a></h1><p>一个典型的例子就是<code>Comparator</code>接口和<code>Comparator</code>类。下面的代码对我们定义的<code>Point</code>类创建了优先队列<code>PriorityQueue</code>。默认情况下，<code>PrioriryQueue</code>里的对象需要是实现了<code>Comparable</code>接口的，这样队列才能对元素进行比较，从而改变优先级。如果没有，我们则需要给<code>Point</code>单独设计一个<code>Comparator</code>类作为参数来创建队列，这样队列才能进行比较的操作，决定优先级。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新定义的Point类实现Comparable接口，重写CompareTo方法</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Point</span>&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.x = a;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.y = b;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Point o)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Double.compare(Math.pow(x, <span class=\"number\">2</span>) + Math.pow(y, <span class=\"number\">2</span>), Math.pow(o.x, <span class=\"number\">2</span>) + Math.pow(o.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"(\"</span> + x + <span class=\"string\">\",\"</span> + y + <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PriorityQueue&lt;Point&gt; pHeap1 = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;();</span><br><span class=\"line\">        PriorityQueue&lt;Point&gt; pHeap2 = <span class=\"keyword\">new</span> PriorityQueue&lt;&gt;(<span class=\"keyword\">new</span> Comparator&lt;Point&gt;() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建一个新的Comparator匿名类作为参数初始化优先队列</span></span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(Point o1, Point o2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> Double.compare(Math.pow(o2.x, <span class=\"number\">2</span>) + Math.pow(o2.y, <span class=\"number\">2</span>), Math.pow(o1.x, <span class=\"number\">2</span>) + Math.pow(o1.y, <span class=\"number\">2</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">            Point p = <span class=\"keyword\">new</span> Point(i, i);</span><br><span class=\"line\">            pHeap1.offer(p);</span><br><span class=\"line\">            pHeap2.offer(p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\\nminHeap of Points\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pHeap1.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.print(pHeap1.poll().toString() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"\\nmaxHeap of Points\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(pHeap2.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            System.out.print(pHeap2.poll().toString() + <span class=\"string\">\" \"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>来看一下实现接口或者继承类需要实现的方法：</p>\n<ul><li><code>Comparable</code>必须实现<code>CompareTo(o2)</code>方法</li>\n</ul><p>对于调用该方法的实例<code>o</code>来说：<code>o</code>定义上大于<code>o2</code>，方法返回正值；<code>o</code>定义上与<code>o2</code>相等，方法返回零；<code>o</code>定义上小于<code>o2</code>，方法返回负值。</p>\n<ul><li><code>Comparator</code>必须实现<code>compare(o1, o2)</code>方法</li>\n</ul><p>优先队列会直接调用这个继承自<code>Comparator</code>的匿名类，来比较内部的元素。<code>o1</code>定义上大于<code>o2</code>，方法返回正值；<code>o1</code>定义上与<code>o2</code>相等，方法返回零；<code>o1</code>定义上小于<code>o2</code>，方法返回负值。</p>\n<p>不使用特定的参数初始化，<code>PriorityQueue</code>会使用泛型类本身的<code>CompareTo()</code>来构成一个最小堆。所以在上面的代码中，我们得到的第一个优先队列是最小堆。<code>Double.compare(o1, o2)</code>返回的的按照<code>o1 -&gt; o2</code>这样的顺序来比较大小的，因此，想要得到最大堆就把这个顺序给翻转一下就行了，即匿名类的<code>compare(o1, o2)</code>方法返回的实际是<code>Double.compare(o2, o1)</code>的结果。</p>\n<h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><ul><li>Java面向对象三大特性：封装、继承、多态</li>\n<li>重载针对类内部的同名函数，重写（覆写）针对类继承中方法的再实现</li>\n<li>抽象类和接口都是为了规范高级类的行为，具体的比较如下</li>\n</ul><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th style=\"padding:0\"></th><th align=\"left\">abstract class</th><th>interface</th></tr>\n</thead><tbody><tr>\n<td align=\"left\">继承</td><td align=\"left\">只能extends一个class</td><td>可以implements多个interface</td></tr>\n<tr>\n<td align=\"left\">字段</td><td align=\"left\">可以定义实例字段</td><td>不能定义实例字段</td></tr>\n<tr>\n<td align=\"left\">抽象方法</td><td align=\"left\">可以定义抽象方法</td><td>可以定义抽象方法</td></tr>\n<tr>\n<td align=\"left\">非抽象方法</td><td align=\"left\">可以定义非抽象方法</td><td>可以定义default方法</td></tr>\n</tbody></table></div></div><h1 id=\"reference\">Reference<a href=\"#reference\" title=\"Reference\"></a></h1><ul><li><a href=\"https://www.geeksforgeeks.org/difference-between-abstract-class-and-interface-in-java/\" target=\"_blank\">geeksforgeeks - Difference between Abstract Class and Interface in Java</a></li>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1260456790454816\" target=\"_blank\">廖雪峰Java教程</a></li>\n</ul>","prev":{"title":"MAC上配置Hexo部署GitHub Page","link":"post/MAC-hexo"},"next":{"title":"Java的嵌套类和内部类","link":"post/嵌套类和内部类"},"plink":"https://magi003769.github.io/post/接口和抽象类/","toc":[{"id":"java面向对象编程的三大特性","title":"Java面向对象编程的三大特性","index":"1"},{"id":"重载与重写","title":"重载与重写","index":"2"},{"id":"抽象类","title":"抽象类","index":"3"},{"id":"接口","title":"接口","index":"4"},{"id":"举个栗子","title":"举个栗子","index":"5"},{"id":"summary","title":"Summary","index":"6"},{"id":"reference","title":"Reference","index":"7"}]}