{"title":"Queue and BFS","date":"2019-04-25T07:00:00.000Z","date_formatted":{"ll":"Apr 25, 2019","L":"04/25/2019","MM-DD":"04-25"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/HD_queue.jpg","link":"post/Queue","tags":["BFS","LeetCode","Queue"],"categories":["算法数据结构"],"updated":"2019-05-26T23:34:28.000Z","content":"<p>LeetCode上面 <code>Queue &amp; Stack</code> 专题的搬运：Queue部分。（可能也有那么一点自己的理解，存疑）</p>\n<a id=\"more\"></a><h1 id=\"queue\">Queue<a href=\"#queue\" title=\"Queue\"></a></h1><p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/03/screen-shot-2018-05-03-at-151021.png\" class=\"φcy\" alt=\"queue\"></p>\n<p>Queue 是一个 <strong>FIFO</strong> 的数据结构。在这个类似数组的结构里，我们无法像一般的array一样通过index去访问其中的元素，且我们<strong>一般只允许在末尾增加元素，在头部删减元素</strong>。这两个操作分别被称为 enqueue 和 dequeue。</p>\n<h2 id=\"queue-and-bfs\">Queue and BFS<a href=\"#queue-and-bfs\" title=\"Queue and BFS\"></a></h2><p>BFS: Breadth-first Search (BFS) 的常见应用是寻找<strong>最短路径</strong>。很多时候 BFS 是用在 Tree 或者 Graph 之类的数据结构中，经常用来做遍历或找最短路径。不过它也可以用在其他数据结构中。</p>\n<blockquote>\n<p>It will be important to determine the nodes and the edges before doing BFS in a specific question. Typically, the node will be an actual node or a status while the edge will be an actual edge or a possible transition</p>\n</blockquote>\n<p><img src=\"https://upload.wikimedia.org/wikipedia/commons/4/46/Animated_BFS.gif\" class=\"φcy\" alt=\"shortest-path\"></p>\n<p>以上面这副图为例子，我们想要从节点 a 到达节点 h。创建一个空的 <code>queue</code>，将根节点先添加进去。进入循环，将 queue 前部的节点 pop 出来，访问这个节点的子节点，并添加进 queue 里。如此循环下去，直到 queue 为空。每一次循环中，BFS都会更新一个深度变量 <code>step</code>，这也是算法最终的结果。下面是一个 BFS 的一个模板。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">BFS</span><span class=\"params\">(Node root, Node target)</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    Set&lt;Node&gt; visited;  <span class=\"comment\">// store all the nodes that we've visited</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> step = <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    add root to visited;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            Node cur = the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next is not in used) &#123;</span><br><span class=\"line\">                    add next to queue;</span><br><span class=\"line\">                    add next to visited;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                remove the first node from queue;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是这里面有一个变量是 <code>visited</code>，在有向图中，如果没有 cyclic 的情况出现，这个变量其实是没有必要的。但是有些问题中，我们必须保证同一节点不会被访问两次，否则会陷入死循环。这是有一个变量或者方法实现 <code>visited</code> 的效果就很重要了。下面用一个题目来展示一下 Queue 的实际应用：<a href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_blank\">200. Number of Islands</a>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numIslands</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type grid: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num_island = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[i][j] == <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">                    num_island += <span class=\"number\">1</span></span><br><span class=\"line\">                    self.bfs((i,j), grid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num_island</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bfs</span><span class=\"params\">(self, coord, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        This function receives a seed points and </span></span><br><span class=\"line\"><span class=\"string\">        convert the \"1\" to \"0\" to eliminate current island</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        w, h = len(grid), len(grid[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\"># construct queue</span></span><br><span class=\"line\">        queue = []</span><br><span class=\"line\">        <span class=\"comment\"># Add pixel to queue and set to zero (used)</span></span><br><span class=\"line\">        queue.append(coord)</span><br><span class=\"line\">        grid[coord[<span class=\"number\">0</span>]][coord[<span class=\"number\">1</span>]] = <span class=\"string\">\"0\"</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> len(queue):</span><br><span class=\"line\">            cur = queue.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> neib <span class=\"keyword\">in</span> [(max(cur[<span class=\"number\">0</span>]<span class=\"number\">-1</span>, <span class=\"number\">0</span>), cur[<span class=\"number\">1</span>]),</span><br><span class=\"line\">                        (min(cur[<span class=\"number\">0</span>]+<span class=\"number\">1</span>, w<span class=\"number\">-1</span>), cur[<span class=\"number\">1</span>]),</span><br><span class=\"line\">                        (cur[<span class=\"number\">0</span>], max(cur[<span class=\"number\">1</span>]<span class=\"number\">-1</span>, <span class=\"number\">0</span>)),</span><br><span class=\"line\">                        (cur[<span class=\"number\">0</span>], min(cur[<span class=\"number\">1</span>]+<span class=\"number\">1</span>, h<span class=\"number\">-1</span>))]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[neib[<span class=\"number\">0</span>]][neib[<span class=\"number\">1</span>]] == <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">                    queue.append(neib)</span><br><span class=\"line\">                    grid[neib[<span class=\"number\">0</span>]][neib[<span class=\"number\">1</span>]] = <span class=\"string\">\"0\"</span> <span class=\"comment\"># key point</span></span><br></pre></td></tr></table></figure><p>主方法 <code>numIsland()</code>，遍历所给 <code>grid</code> 里是 <code>&quot;1&quot;</code> 的元素。在某一次循环中，以改点为种子点，找到它所在的岛屿。每次调用 <code>bfs()</code>就会创建一个记录岛屿所包含点的 <code>queue</code>，每次 pop 出最早加入点，在判断其四邻域是否是也属于岛屿，如果属于则添加进 <code>queue</code>。如此循环，直到 <code>queue</code> 为空。</p>\n<p>这个场景中，每个节点的子节点是他的四邻域，从图的角度来说，会出现 cyclic 的情况。另外一点就是主函数是遍历所有为 <code>&quot;1&quot;</code> 的点的，如果没有 <code>visited</code> 这个机制的话，一定会出现重复。所以在每次调用 <code>bfs()</code> 处理一个岛屿的时候，可以想象到是把这个岛屿从图中抹去的一个过程。</p>\n<h1 id=\"reference\">Reference<a href=\"#reference\" title=\"Reference\"></a></h1><ul><li><a href=\"https://leetcode.com/explore/learn/card/queue-stack/\" target=\"_blank\">LeetCode Explore: Queue &amp; Stack</a></li>\n</ul>","prev":{"title":"Linked List","link":"post/linked-list"},"next":{"title":"Stack and DFS","link":"post/Stack"},"plink":"https://magi003769.github.io/post/Queue/","toc":[{"id":"queue","title":"Queue","index":"1","children":[{"id":"queue-and-bfs","title":"Queue and BFS","index":"1.1"}]},{"id":"reference","title":"Reference","index":"2"}]}