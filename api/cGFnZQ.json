{"per_page":7,"total":8,"current":1,"data":[{"title":"强行置顶：关于这个博客 About this blog","date":"2069-01-01T08:00:00.000Z","date_formatted":{"ll":"Jan 1, 2069","L":"01/01/2069","MM-DD":"01-01"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/header_imgs_home-2.jpg","excerpt":"<blockquote>\n<p><strong><em>“If you can’t explain it to a six year old, you don’t understand it yourself”</em></strong> </p>\n<p>—— Albert Einstein </p>\n</blockquote>","link":"post/关于这个博客","tags":["一些想法"],"categories":["自用树洞"]},{"title":"LRU Cache和LinkedHashMap","date":"2020-05-17T07:00:00.000Z","date_formatted":{"ll":"May 17, 2020","L":"05/17/2020","MM-DD":"05-17"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1509475826633-fed577a2c71b.jpeg","excerpt":"<p>讲一下LRU Cache和LinkedHashMap。很多公司在面试的时候会考到这个，这个也是刷题的时候一直没仔细研究的，这里就专门拉出来一个post梳理一下这个。</p>","link":"post/LRU和LinkedHashMap","tags":["LRU","LeetCode","LinkedHashMap"],"categories":["算法数据结构"]},{"title":"Java的Concurrent集合和Atomic类","date":"2020-05-16T07:00:00.000Z","date_formatted":{"ll":"May 16, 2020","L":"05/16/2020","MM-DD":"05-16"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1472457897821-70d3819a0e24.jpeg","excerpt":"<p>之前几篇post已经介绍了Java中如何实现线程安全的类，比如任务管理器就实现了一个线程安全的<code>BlockingQueue</code>，它允许多线程的读写操作。这里介绍一下Java标准库提供的线程安全的并发集合类，他们都在<code>java.util.concurrent</code>中。另外，<code>java.util.concurrent.atomic</code>还提供了一组原子操作的封装类。</p>","link":"post/Java的Concurrent集合和Atomic类","tags":["Java","多线程"],"categories":["Java"]},{"title":"Java多线程的几种Lock","date":"2020-05-15T07:00:00.000Z","date_formatted":{"ll":"May 15, 2020","L":"05/15/2020","MM-DD":"05-15"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1501959181532-7d2a3c064642.jpeg","excerpt":"<p>前面多线程相关的post介绍了线程的同步、<code>synchronized</code>关键字的使用、加锁以及死锁等概念。这一篇介绍一下Java提供的其他加锁机制：使用<code>ReentrantLock</code>，以及配合<code>Condition</code>实现多线程之间的协调。另外，还会介绍<code>ReadWriteLock</code>和<code>StampedLock</code>两种锁。</p>","link":"post/Java多线程使用ReentrantLock等","tags":["Java","多线程"],"categories":["Java"]},{"title":"Java多线程之间的协调","date":"2020-05-14T07:00:00.000Z","date_formatted":{"ll":"May 14, 2020","L":"05/14/2020","MM-DD":"05-14"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1455461491901-a0990c10d84c.jpeg","excerpt":"<p>前面多线程相关的post介绍了线程的同步、<code>synchronized</code>关键字的使用、加锁以及死锁等概念。<code>synchronized</code>可以解决多线程竞争的问题，竞争使用共享变量的问题。但是它并没有解决多线程之间的协调问题。本篇介绍一下线程之间如何进行协调、<code>wait()</code>和<code>notify()</code>的用法。</p>","link":"post/Java多线程之间的协调","tags":["Java","多线程"],"categories":["Java"]},{"title":"Java线程的同步方法与死锁","date":"2020-05-14T07:00:00.000Z","date_formatted":{"ll":"May 14, 2020","L":"05/14/2020","MM-DD":"05-14"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1553087927-8b09bfbf19b5.jpeg","excerpt":"<p>上一篇提出了Java多线程共享变量的同步问题，比因此引入了原子性、<code>sychronized</code>关键词以及锁等概念。这一片具体讲多线程同步方法、锁的重入与死锁的概念。</p>","link":"post/Java多线程的同步方法与死锁","tags":["Java","多线程"],"categories":["Java"]},{"title":"Java线程的同步与锁","date":"2020-05-13T07:00:00.000Z","date_formatted":{"ll":"May 13, 2020","L":"05/13/2020","MM-DD":"05-13"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1530303263041-b5ca33678f04.jpeg","excerpt":"<p>前面两篇讲了Java多线程相关的概念以及如何创建线程，这中间讨论到了共享变量的同步问题，并引入了<code>volatile</code>关键词。这里我们进一步讨论线程之间的同步，引入锁的概念，并讲<code>volatile</code>和<code>synchronized</code>进行比较。</p>","link":"post/Java线程的同步与锁","tags":["Java","多线程"],"categories":["Java"]}]}