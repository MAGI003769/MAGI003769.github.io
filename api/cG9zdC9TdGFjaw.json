{"title":"Stack and DFS","date":"2019-04-25T07:00:00.000Z","date_formatted":{"ll":"Apr 25, 2019","L":"04/25/2019","MM-DD":"04-25"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/HD_stack.jpeg","link":"post/Stack","tags":["DFS","LeetCode","Stack"],"categories":["算法数据结构"],"updated":"2019-05-26T23:34:38.000Z","content":"<p>LeetCode上面 <code>Queue &amp; Stack</code> 专题的搬运：Stack部分。（可能也有那么一点自己的理解，存疑）</p>\n<a id=\"more\"></a><h1 id=\"stack\">Stack<a href=\"#stack\" title=\"Stack\"></a></h1><p>使用 <code>stack</code> 经常是这样的场景：<strong>当前的某一步的操作需要之前的一些信息或者结果，或者说对节点和元素的处理与访问它们的顺序是相反的。</strong> 比如说 Reverse Polish Calculator，我们需要保留之前的数字，在遇到计算符的时候，使用最近的两个数字进行计算。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">infix      reverse-Polish</span><br><span class=\"line\">-------    --------------</span><br><span class=\"line\">a+b*c      a b c * +</span><br><span class=\"line\">(a+b)*c    a b + c *</span><br></pre></td></tr></table></figure><p>这个时候就可以使用 <code>stack</code>，在遇到数字把数字 push 进去，遇到计算符把 <code>stack</code> 最顶端的两个元素 pop 出来，并将计算结果 push 回去。</p>\n<h1 id=\"stack-and-dfs\">Stack and DFS<a href=\"#stack-and-dfs\" title=\"Stack and DFS\"></a></h1><p>与 BFS 很相似，Depeth-First Search 也可以找到从根节点到目标节点的路径，但是这个路径并不一定是最短的。<strong>总的来说，DFS 方法中，我们只有在到达最深的节点时，才会开始回溯。</strong>这也是这一方法名字的由来。</p>\n<blockquote>\n<p>As a result, the first path you found in DFS is not always the shortest path. For instance, in the example above, we successfully found a path <code>A-&gt;C-&gt;F-&gt;G</code> and stop the DFS. But this is not the shortest path from <code>A</code> to <code>G</code>.</p>\n</blockquote>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/dfs.gif\" class=\"φcy\" alt=\"DFSvsBFS\"></p>\n<p>我们对节点的处理顺序（回溯）和我们添加节点的顺序是完全相反的，所以我们才会选择 stack 来实现 DFS。下面是 DFS 的一个模版。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">DFS</span><span class=\"params\">(Node cur, Node target, Set&lt;Node&gt; visited)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (next : each neighbor of cur) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">            add next to visted;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">true</span> <span class=\"keyword\">if</span> <span class=\"title\">DFS</span><span class=\"params\">(next, target, visited)</span> </span>== <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们可以发现，这是一个递归方法。当时用这种递归方法时，我们看上去没有用任何的 stack。然而实际上，我们仍然用了系统提供的隐式的 stack，称之为 <a href=\"https://en.wikipedia.org/wiki/Call_stack\" target=\"_blank\">Call Stack</a>。下面的代码，以<a href=\"https://leetcode.com/problems/number-of-islands/\" target=\"_blank\">200. Number of Islands</a>作为例子，说明 DFS 的使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">numIslands</span><span class=\"params\">(self, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type grid: List[List[str]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num_island = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(grid)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(grid[<span class=\"number\">0</span>])):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> grid[i][j] == <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">                    num_island += <span class=\"number\">1</span></span><br><span class=\"line\">                    self.bfs((i,j), grid)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num_island</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dfs</span><span class=\"params\">(self, x, y, grid)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &gt;= len(grid) <span class=\"keyword\">or</span> y &gt;= len(grid[<span class=\"number\">0</span>]) <span class=\"keyword\">or</span> x &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> y &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> grid[x][y] != <span class=\"string\">\"1\"</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        grid[x][y] = <span class=\"string\">\"0\"</span></span><br><span class=\"line\">        self.dfs(x<span class=\"number\">-1</span>, y, grid)</span><br><span class=\"line\">        self.dfs(x+<span class=\"number\">1</span>, y, grid)</span><br><span class=\"line\">        self.dfs(x, y<span class=\"number\">-1</span>, grid)</span><br><span class=\"line\">        self.dfs(x, y+<span class=\"number\">1</span>, grid)</span><br></pre></td></tr></table></figure><h1 id=\"stack-overflow\">Stack Overflow<a href=\"#stack-overflow\" title=\"Stack Overflow\"></a></h1><p>使用递归方法的一个优点就是容易实现，但是当递归的深度太大时，会出现 <code>stack overflow</code>。这个时候我们其实可以使用 BFS 或者使用 <code>explicit stack</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">DFS</span><span class=\"params\">(<span class=\"keyword\">int</span> root, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;Node&gt; visited;</span><br><span class=\"line\">    Stack&lt;Node&gt; stack;</span><br><span class=\"line\">    add root to stack;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (s is not empty) &#123;</span><br><span class=\"line\">        Node cur = the top element in stack;</span><br><span class=\"line\">        remove the cur from the stack;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">                add next to visited;</span><br><span class=\"line\">                add next to stack;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里我们用一个 while 循环和 stack 来模拟递归中的 system call stack。以之前GIF里面找路径的问题为例子，从根节点出发，在第一个循环结束后，<code>stack</code> 里面是根节点的子节点。随后再继续进行迭代，将子节点的子节点加入 <code>stack</code>。在到达最深处的时候，不再增加 <code>neibhbor</code> 进 <code>stack</code>，并开始慢慢从中 <code>pop</code> 节点出来知道 <code>stack</code> 变空。</p>\n<p>我们可以注意到 <code>visited</code> 这个 <code>set</code>，它其实是为了防止这样一个情况出现：在回溯的过程中，我们会遇到有其它分支的节点。它的 <code>neighbor</code> 里面其实是包含有之前从 <code>stack</code> 里pop出去的元素。如果再次将它push到 <code>stack</code> 里面，就会出现这样的 </p>\n<h1 id=\"several-examples\">Several Examples<a href=\"#several-examples\" title=\"Several Examples\"></a></h1><p>以下几个题目是刷 LeetCode 上 <a href=\"https://leetcode.com/explore/learn/card/queue-stack/\" target=\"_blank\">Queue &amp; Stack</a> 这个 card 里出现的题目，有几个还挺有趣的。也用到了 <code>stack</code>，就放在这里略微讲解一下</p>\n<h2 id=\"decode-string\">Decode String<a href=\"#decode-string\" title=\"Decode String\"></a></h2><p><a href=\"https://leetcode.com/problems/decode-string\" target=\"_blank\">394.Decode String</a> 这道题就有点巧妙，其实很早之前在水某学校录取群时就见过这个题，要求解析 <code>&quot;3[a2[b]c]de&quot;</code> 这种形式的字符串，其结果是 <code>&quot;abbcabbcabbcde&quot;</code>。其实很容易理解，数字代表中括号内字符串的循环次数。比较恶心的地方在于如何去update这个字符串。基本思路大概就下面三点：</p>\n<ol><li><code>num_stack</code> 和 <code>alpha_stack</code> 存储较为外层的循环次数和字符串</li>\n<li>只有在遇到 <code>&quot;]&quot;</code> 的时候才会更新返回的字符串，先把当前的字符串做重复，在把前一段字符串pop出来做prefix</li>\n<li><code>tmp_num</code> 和 <code>tmp_char</code> 用来处理多位的循环次数和连续的字符串</li>\n</ol><p>下面是具体实现的代码</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decodeString</span><span class=\"params\">(self, s)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type s: str</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: str</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        num_stack = []</span><br><span class=\"line\">        alpha_stack = []</span><br><span class=\"line\">        tmp_str = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        tmp_num = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        prev = <span class=\"string\">\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> char <span class=\"keyword\">in</span> s:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> char.isdigit():</span><br><span class=\"line\">                tmp_num += char</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> char.isalpha():</span><br><span class=\"line\">                tmp_str += char</span><br><span class=\"line\">            <span class=\"keyword\">elif</span> char == <span class=\"string\">\"[\"</span>:</span><br><span class=\"line\">                alpha_stack.append(tmp_str)</span><br><span class=\"line\">                num_stack.append(int(tmp_num))</span><br><span class=\"line\">                tmp_str = <span class=\"string\">\"\"</span></span><br><span class=\"line\">                tmp_num = <span class=\"string\">\"\"</span></span><br><span class=\"line\">            <span class=\"keyword\">elif</span> char == <span class=\"string\">\"]\"</span>:</span><br><span class=\"line\">                prev = alpha_stack.pop()</span><br><span class=\"line\">                tmp_str = tmp_str * num_stack.pop()</span><br><span class=\"line\">                tmp_str = prev + tmp_str</span><br><span class=\"line\">            <span class=\"comment\">#print(tmp_str, num_stack)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> tmp_str</span><br></pre></td></tr></table></figure><h2 id=\"keys-and-rooms\">Keys and Rooms<a href=\"#keys-and-rooms\" title=\"Keys and Rooms\"></a></h2><p><a href=\"https://leetcode.com/problems/keys-and-rooms\" target=\"_blank\">841.Keys and Rooms</a> 这也是一道很有意思的题目，可以把每一个room当成是树里面的一个节点，他所有钥匙的房间是这个节点的子节点。<code>stack</code> 用来储存房间包含的 keys。需要注意的是，<code>stack</code> 中的元素是有重复的，也就是说我们有可能走很多重复的道路。所以已经在 <code>keys</code> 这个set里出现过的就可以直接忽略了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">canVisitAllRooms</span><span class=\"params\">(self, rooms)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type rooms: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack = [<span class=\"number\">0</span>]</span><br><span class=\"line\">        keys = set(stack)</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">            i = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> rooms[i]:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> keys:</span><br><span class=\"line\">                    stack.append(j)</span><br><span class=\"line\">                    keys.add(j)</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> len(rooms) == len(keys):</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> len(rooms) == len(keys)</span><br></pre></td></tr></table></figure><p> 这里插播一条关于 <code>set</code> 这个数据结构的小知识，<code>set</code> 其实是基于哈希的一种数据结构，查找起来比内建的 <code>list</code> 更加快捷，且在使用方法 <code>.add()</code> 添加元素时，如果添加的内部已有的元素，将不再重复添加，非常方便。这种基于哈希的数据结构在 Java 和 C++ 里面其实都是有的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HashSet&lt;Integer&gt; seen = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;(); seen.add(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">unordered_set</span>&lt;<span class=\"keyword\">int</span>&gt; seen = &#123;<span class=\"number\">0</span>&#125;;</span><br></pre></td></tr></table></figure><h1 id=\"reference\">Reference<a href=\"#reference\" title=\"Reference\"></a></h1><ul><li><a href=\"http://users.monash.edu/~lloyd/tildeAlgDS/Stack/\" target=\"_blank\">Monash - Stack</a></li>\n<li><a href=\"https://stackoverflow.com/questions/23981391/how-exactly-does-the-callstack-work\" target=\"_blank\">stackoverflow - Call Stack</a></li>\n<li><a href=\"https://leetcode.com/explore/learn/card/queue-stack/\" target=\"_blank\">LeetCode Explore: Queue &amp; Stack</a></li>\n</ul>","prev":{"title":"Queue and BFS","link":"post/Queue"},"next":{"title":"Binary Tree（2）","link":"post/Tree-02"},"plink":"https://magi003769.github.io/post/Stack/","toc":[{"id":"stack","title":"Stack","index":"1"},{"id":"stack-and-dfs","title":"Stack and DFS","index":"2"},{"id":"stack-overflow","title":"Stack Overflow","index":"3"},{"id":"several-examples","title":"Several Examples","index":"4","children":[{"id":"decode-string","title":"Decode String","index":"4.1"},{"id":"keys-and-rooms","title":"Keys and Rooms","index":"4.2"}]},{"id":"reference","title":"Reference","index":"5"}]}