{"title":"Linked List","date":"2019-05-01T07:00:00.000Z","date_formatted":{"ll":"May 1, 2019","L":"05/01/2019","MM-DD":"05-01"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/HD_linked-list.jpeg","link":"post/linked-list","tags":["LeetCode","Linked List"],"categories":["算法数据结构"],"updated":"2019-05-26T23:34:16.000Z","content":"<p>LeetCode Explore <a href=\"https://leetcode.com/explore/learn/card/linked-list/210/doubly-linked-list/\" target=\"_blank\">Linked List</a>专题的搬运，主要介绍链表的概念和常见问题，概念部分夹杂一些参考书《数据结构预算法Python实现》上面的内容。</p>\n<a id=\"more\"></a><h1 id=\"linked-list\">Linked List<a href=\"#linked-list\" title=\"Linked List\"></a></h1><p>Python 中 array-based list class，虽然这些类已经进行了高度的优化而且是储存信息的不错选择，但是它有一系列的缺点：</p>\n<blockquote>\n<ol><li>dynamic array的长度可能比实际上的元素个数要多，</li>\n<li>操作的 amortized bounds (???) 对于实际</li>\n<li>中间元素的插入或删减代价非常高</li>\n</ol></blockquote>\n<p>使用链表可以避免以上的三个问题，但是链表无法高效的通过 index 访问元素。</p>\n<h2 id=\"singly-linked-list\">Singly Linked List<a href=\"#singly-linked-list\" title=\"Singly Linked List\"></a></h2><p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/12/screen-shot-2018-04-12-at-152754.png\" class=\"φcy\" alt=\"singly-linked\"></p>\n<p>链表的第一个和最后一个元素分别是链表的<code>head</code>和<code>tail</code>。我们可以遍历从头到尾的所有节点。Singly Linked Lists，即单项链表，是最基本的链表，每个节点只有指向下一个节点的 pointer。链表在内存中的表示依赖于许多对象的集合：每个节点是unique的对象，另外还有一个对象指向的是整个链表。<strong>一个链表实例至少要有 head 的 reference，而 tail 的 reference 则并不一定需要，我们可以从头遍历整个链表找到它。</strong>但是我们一般会保存它，来避免麻烦的遍历。出于同样的思考，一个链表实例也要储存它节点的个数以便于获得整个链表的长度<code>size</code>。</p>\n<p>然而在LeetCode刷题的过程中，往往<code>tail</code>和<code>size</code>在链表的实例中都是不存在的，这也给我们刷题带来了更大的挑战。比如一些提前预知链表长度就可以轻松解决的问题，在没有<code>size</code>的情况下就会变得很复杂，只能通过遍历和一些特殊方法解决，e.g. <code>two pointer</code>。</p>\n<h2 id=\"cirularly-linked-list\">Cirularly Linked List<a href=\"#cirularly-linked-list\" title=\"Cirularly Linked List\"></a></h2><p>循环链表<code>tail</code>的<code>next</code>指向链表的<code>head</code>，因此在实现循环链表的过程中，我们实际上只需要指定<code>tail</code>即可。</p>\n<h2 id=\"doubly-linked-list\">Doubly Linked List<a href=\"#doubly-linked-list\" title=\"Doubly Linked List\"></a></h2><p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/17/screen-shot-2018-04-17-at-161130.png\" class=\"φcy\" alt=\"double-linked\"></p>\n<p>前面利用 Singly linked list 实现的简单 stack 和 queue 里面，stack 只对 head 处的节点做删减操作，queue 只对 head 处的节点做删除，tail 处的节点做增加。这些都没有涉及到对链表尾部的删除操作，这也正是单向链表的一个重要缺陷：<strong>无法高效地删除尾部或者任意中间节点进行</strong>。即使单项链表中有 tail 的属性指向链表的尾部，我们也无法了解就得为不节点之前是什么，无法将它的 next 改为 Null。</p>\n<p>具体的双向链表实现可以参考<a href=\"https://leetcode.com/problems/design-linked-list/\" target=\"_blank\">707. Design Linked List</a>中的submission。这里讲一下<code>addAtIndex</code>和<code>deleteAtIndex</code>这两个操作的实现。首先是<code>addAtIndex</code>，当链表的下标从0开始的时候，我们从<code>head</code>开始用循环来遍历节点。当循环的次数为<code>k</code>时，指针最终指向的就是第<code>k</code>个元素。当使用<code>addAtIndex(k, val)</code>时，我们实际上只需要遍历到第<code>k-1</code>个元素即可，剩下的就是修改涉及到的三个节点各自的前后关系就可以。当然不要忘记修改<code>self.size</code>，这个也同样关键。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(self, index, val)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span></span><br><span class=\"line\"><span class=\"string\">        :type index: int</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: None</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &gt; self.size:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">            self.addAtHead(val)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> index == self.size:</span><br><span class=\"line\">            self.addAtTail(val)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            add = self._Node(val)</span><br><span class=\"line\">            prev = self.head</span><br><span class=\"line\">            <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(index<span class=\"number\">-1</span>):</span><br><span class=\"line\">                prev = prev.next</span><br><span class=\"line\">            next_ = prev.next</span><br><span class=\"line\">            add.prev = prev</span><br><span class=\"line\">            add.next = next_</span><br><span class=\"line\">            prev.next = add</span><br><span class=\"line\">            next_.prev = add</span><br><span class=\"line\">            self.size += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><p>稍微有点坑的是<code>deleteAtIndex</code>这个操作，会有一些额外的特殊的case需要处理。比如当链表只有一个节点的时候，<code>self.head</code>和<code>self.tail</code>都指向同一节点，且节点的<code>prev</code>和<code>next</code>都为空。如果不处理这个情况的话，后续的情况<code>cur.prev.next</code>这样的对象会报错。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(self, index)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        Delete the index-th node in the linked list, if the index is valid.</span></span><br><span class=\"line\"><span class=\"string\">        :type index: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: None</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> index &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> index &gt;= self.size:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        cur = self.head</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(index):</span><br><span class=\"line\">            cur = cur.next</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.size == <span class=\"number\">1</span>:</span><br><span class=\"line\">            self.head = <span class=\"literal\">None</span></span><br><span class=\"line\">            self.tail = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cur <span class=\"keyword\">is</span> self.head:</span><br><span class=\"line\">            cur.next.prev = cur.prev</span><br><span class=\"line\">            self.head = cur.next</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> cur <span class=\"keyword\">is</span> self.tail:</span><br><span class=\"line\">            cur.prev.next = cur.next</span><br><span class=\"line\">            self.tail = cur.prev</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            cur.prev.next = cur.next</span><br><span class=\"line\">            cur.next.prev = cur.prev</span><br><span class=\"line\">        self.size -= <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><h1 id=\"classic-problem\">Classic Problem<a href=\"#classic-problem\" title=\"Classic Problem\"></a></h1><p>这一届记录几个非常有趣的链表算法题。都是很常用的操作，比如<code>reverse</code>和<code>delete</code>。这些操作都可以在<code>array</code>中非常轻易的实现（准确的说是各种各级语言已经提供了相关的方法，还有方便的index访问机制），这里就通过时先来感受链表的蛋疼所在。</p>\n<h2 id=\"reverse-linked-list\">Reverse Linked List<a href=\"#reverse-linked-list\" title=\"Reverse Linked List\"></a></h2><p>解决<a href=\"https://leetcode.com/problems/reverse-linked-list/\" target=\"_blank\">206. Reverse Linked List</a>，除了初始的<code>head</code>，还需要而外的两个指针<code>curr</code>和<code>prev</code>。<code>head</code>用来遍历链表中的节点， <code>curr</code>用来确定当前需要操作的节点，<code>prev</code>则是该节点在新链表中所指向的节点。</p>\n<p><img src=\"https://media.geeksforgeeks.org/wp-content/cdn-uploads/RGIF2.gif\" class=\"φcy\" alt=\"reverse-linked\"></p>\n<p>下面是Python实现，其中的指针等价关系为：<code>cur == curr</code>、<code>new_head == prev</code>。操作顺序和指针使用上和上面的gif虽然有区别，但是基本的逻辑都大致相同。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reverseList</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        new_head = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> head:</span><br><span class=\"line\">            cur = head</span><br><span class=\"line\">            head = head.next</span><br><span class=\"line\">            cur.next = new_head</span><br><span class=\"line\">            new_head = cur</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new_head</span><br></pre></td></tr></table></figure><h2 id=\"palindrome-linked-list\">Palindrome Linked List<a href=\"#palindrome-linked-list\" title=\"Palindrome Linked List\"></a></h2><p><a href=\"https://leetcode.com/problems/palindrome-linked-list/\" target=\"_blank\">234. Palindrome Linked List</a>遍历整个链表，将元素的值存到一个<code>list</code>里面再<code>[::-1]</code>一下就非常容易做，但是这样我们就有<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.977ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2143 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">O(n)</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4F\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4F\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"763\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6E\" x=\"1153\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-29\" x=\"1753\" y=\"0\"></use>\n</g>\n</svg>的空间复杂度。而题目要求我们做到<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.977ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2143 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">O(n)</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4F\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMATHI-6E\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4F\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"763\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMATHI-6E\" x=\"1153\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-29\" x=\"1753\" y=\"0\"></use>\n</g>\n</svg>的时间复杂度和<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"4.745ex\" height=\"2.843ex\" style=\"vertical-align: -0.838ex;\" viewBox=\"0 -863.1 2043 1223.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">O(1)</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4F\" d=\"M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-28\" d=\"M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-29\" d=\"M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4F\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-28\" x=\"763\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-31\" x=\"1153\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-29\" x=\"1653\" y=\"0\"></use>\n</g>\n</svg>的空间复杂度。由于无法像<code>array</code>一样使用index的方式来访问元素且链表示单向的，我们就需要一个办法找到链表的中间位置。这个问题可以利用链表中的<a><code>Tow Pointer</code></a> 方法来解决：<code>slow</code>指针步长为1，<code>fast</code>指针步长为2。这样在<code>fast</code>到达链表尾部的时候，<code>slow</code>就位于链表的中间位置。<strong>当节点个数为奇数时，<code>slow</code>停在正中间的节点；当节点个数为偶数时，则停在<code>n/2+1</code>处。</strong>这个已经在之前链表的双指针方法里面讨论过了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(self, head)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type head: ListNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"comment\"># Get slow pointer to the middle of list</span></span><br><span class=\"line\">        fast, slow = head, head</span><br><span class=\"line\">        <span class=\"keyword\">while</span> fast <span class=\"keyword\">and</span> fast.next:</span><br><span class=\"line\">            fast = fast.next.next</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">        <span class=\"comment\"># reverse second half of list</span></span><br><span class=\"line\">        new_head = <span class=\"literal\">None</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> slow:</span><br><span class=\"line\">            cur = slow</span><br><span class=\"line\">            slow = slow.next</span><br><span class=\"line\">            cur.next = new_head</span><br><span class=\"line\">            new_head = cur</span><br><span class=\"line\">        <span class=\"comment\"># check</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> new_head:</span><br><span class=\"line\">            print(new_head.val, head.val)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> new_head.val != head.val:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            head = head.next</span><br><span class=\"line\">            new_head = new_head.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure><p>具体的实现分成几个步骤：获取中间位置、将后半部分链表反向、从<code>head</code>和中间位置<code>new_head</code>开始进行比较。这里面会用到之前的反向链表的方法。<code>slow</code>相当于原始链表的起始位置，这个起始位置仍然是可以由<code>head</code>开始遍历到。也就是说，整个链表实际上并没有被切分，只是后面的部分被反转了而已。因此不用考虑当元素个数为奇数的时候，中间元素是否<code>head</code>和<code>new_head</code>是否都能遍历到。</p>\n<h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><p>再来总结一下链表（单项和双向）的一些性质：</p>\n<ol><li>无法在constant time内访问链表的任意位置</li>\n<li>在某已确定节点后或者链表开头处添加元素的复杂度是<code>O(1)</code></li>\n<li>删除第一个节点的复杂度是<code>O(1)</code></li>\n</ol><p>但是在删除节点（包括最后一个节点）时会有一些不同的地方需要注意：单项链表因为节点没有<code>prev</code>信息，再删除时复杂度会很高，是<code>O(N)</code>；而双向链表则是<code>O(1)</code>。</p>\n<p><img src=\"https://s3-lc-upload.s3.amazonaws.com/uploads/2018/04/29/screen-shot-2018-04-28-at-174531.png\" class=\"φcy\" alt=\"comparison\"></p>\n<p>上面的这个表格是集中数据结构操作复杂度的一个对比，不难看出链表除了在按下表访问元素上劣势，在删减操作上还是很有优势的。因此在选择时我们可以使用这样的原则：</p>\n<blockquote>\n<p>If you need to add or delete a node frequently, a linked list could be a good choice.</p>\n<p>If you need to access an element by index often, an array might be a better choice than a linked list.</p>\n</blockquote>\n","prev":{"title":"链表的双指针","link":"post/链表的双指针"},"next":{"title":"Queue and BFS","link":"post/Queue"},"plink":"https://magi003769.github.io/post/linked-list/","toc":[{"id":"linked-list","title":"Linked List","index":"1","children":[{"id":"singly-linked-list","title":"Singly Linked List","index":"1.1"},{"id":"cirularly-linked-list","title":"Cirularly Linked List","index":"1.2"},{"id":"doubly-linked-list","title":"Doubly Linked List","index":"1.3"}]},{"id":"classic-problem","title":"Classic Problem","index":"2","children":[{"id":"reverse-linked-list","title":"Reverse Linked List","index":"2.1"},{"id":"palindrome-linked-list","title":"Palindrome Linked List","index":"2.2"}]},{"id":"summary","title":"Summary","index":"3"}]}