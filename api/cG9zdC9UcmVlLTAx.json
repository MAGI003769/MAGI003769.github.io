{"title":"Binary Tree（1）","date":"2019-04-05T07:00:00.000Z","date_formatted":{"ll":"Apr 5, 2019","L":"04/05/2019","MM-DD":"04-05"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/hello-i-m-nik-1399233-unsplash.jpg","link":"post/Tree-01","tags":["Binary Tree","LeetCode"],"categories":["算法数据结构"],"updated":"2019-05-17T08:10:06.000Z","content":"<p>LeetCode 上面 <a href=\"https://leetcode.com/explore/learn/card/data-structure-tree/\" target=\"_blank\">Binary Tree</a> 专题的搬运。介绍二叉树的基本概念和一些 LeetCode 相关题目。</p>\n<a id=\"more\"></a><h1 id=\"二叉树\">二叉树<a href=\"#二叉树\" title=\"二叉树\"></a></h1><p><code>Tree</code> 是非常常用的数据结构，用来模拟一种分级的树结构。树的每一个 <code>Node</code> 都有它的 value 和若干个 child node。同图的角度来看，树结构其实是非对称的有向图，他拥有 <svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"2.064ex\" height=\"2.176ex\" style=\"vertical-align: -0.338ex;\" viewBox=\"0 -791.3 888.5 936.9\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">N</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4E\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4E\" x=\"0\" y=\"0\"></use>\n</g>\n</svg> nodes 和 <svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"6.066ex\" height=\"2.343ex\" style=\"vertical-align: -0.505ex;\" viewBox=\"0 -791.3 2611.9 1008.6\" role=\"img\" focusable=\"false\" xmlns=\"http://www.w3.org/2000/svg\" aria-labelledby=\"MathJax-SVG-1-Title\">\n<title id=\"MathJax-SVG-1-Title\">N-1</title>\n<defs aria-hidden=\"true\">\n<path stroke-width=\"1\" id=\"E1-MJMATHI-4E\" d=\"M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-2212\" d=\"M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z\"></path>\n<path stroke-width=\"1\" id=\"E1-MJMAIN-31\" d=\"M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z\"></path>\n</defs>\n<g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"matrix(1 0 0 -1 0 0)\" aria-hidden=\"true\">\n <use xlink:href=\"#E1-MJMATHI-4E\" x=\"0\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-2212\" x=\"1110\" y=\"0\"></use>\n <use xlink:href=\"#E1-MJMAIN-31\" x=\"2111\" y=\"0\"></use>\n</g>\n</svg> edges。<code>Binary Tree</code> 则是对典型的一种树结构，其中的每个节点都拥有至多2个子节点，以 <code>left</code> 和 <code>right</code> 作区分。</p>\n<h1 id=\"二叉树遍历\">二叉树遍历<a href=\"#二叉树遍历\" title=\"二叉树遍历\"></a></h1><p>这部分介绍的内容是二叉树的遍历方法，分别有： <code>Pre-order</code>，<code>In-order</code> 和 <code>Post-oder</code> 三种。这三种名字的由来于三个操作的顺序：遍历左分支，遍历右分支，访问该节点的值。每种方法都可以通过迭代和递归两种方法实现，下面会做展示。</p>\n<h2 id=\"preorder\">Preorder<a href=\"#preorder\" title=\"Preorder\"></a></h2><p><code>Pre-oder</code> 顾名思义就是在便利左右分支之前，先访问当前节点的 value，并写入最终返回的数组中。比如从根节点 <code>1</code> 起始，先push到 <code>stack</code> 里面去作为初始化。下面进入循环流程：pop出 <code>stack</code> 最顶端的元素，依次为当前节点 <code>curNode</code>，先将其值写入最红返回的结果，<strong>再先后访问其右节点和左节点</strong>，并把值push到 <code>stack</code> 里面去。当前循环结束，此时 <code>stack</code> 里面是 <code>curNode</code> 的两个子节点。如此循环下去，直到 <code>stack</code> 为空。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/pre-order_tree.gif\" class=\"φcy\" alt=\"pre-order\"></p>\n<p>接口和上面的文字描述并结合图片，可以注意到，我们在这个迭代过程中使用 <code>stack</code> 这一数据结构，是FILO的。也就是说在我们采取先右后左的push顺序下，左分支上的内容总是会先被访问。这正符合 <code>root -&gt; left -&gt; right</code>也就是 <code>Pre-order</code> 的顺序。下面的代码块是具体的 Python 实现。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal_iter</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack, ans = [root], []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">            curNode = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> curNode:</span><br><span class=\"line\">                ans.append(curNode.val)</span><br><span class=\"line\">                stack.append(curNode.right)</span><br><span class=\"line\">                stack.append(curNode.left)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_helper</span><span class=\"params\">(self, node, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">        This function will Fisrtly go through the left side</span></span><br><span class=\"line\"><span class=\"string\">        '''</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            self._helper(node.left, ans)</span><br><span class=\"line\">            self._helper(node.right, ans)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self._helper(root, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><p>上面的代码片段里，<code>preorderTraversal_iter</code> 是迭代方法，而 <code>preorderTraversal</code> 和 <code>_helper</code> 则共同构成了递归的方法。可以看出迭代的方法相对复杂一些，而递归的方法则更加的 intuitive。其内部的顺序直接就是 <code>root -&gt; left -&gt; right</code>。</p>\n<h2 id=\"in-order\">In-order<a href=\"#in-order\" title=\"In-order\"></a></h2><p><code>In-oder</code> 是一种相对比较蛋疼的遍历顺序：<code>left -&gt; root -&gt; right</code>。只有在遍历了左分支之后，才开始访问值并写入最终结果。首先初始化空的 <code>stack</code>，进入外层循环，遍历左分支到尽头（只部分是内层循环），这个过程中把节点push入 <code>stack</code>。该过程结束后，pop出 <code>stack</code> 最顶层的节点进行访问写入结果并转向其右节点一侧开始下一次外层循环。如果有节点不是空，则开始内层循环，遍历这个右节点以下部分的左分支，以此类推。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/in-order_treel.gif\" class=\"φcy\" alt=\"in-order\"></p>\n<p>只有在遍历左分支的过程中，才向 <code>stack</code> 里面 push 节点，这样就保证了 left 分支的优先，有在分叉有右分支的时候，先解决右边的这一部分。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal_iter</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack, ans = [], []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">            <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">                stack.append(root)</span><br><span class=\"line\">                root = root.left</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> stack:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ans</span><br><span class=\"line\">            node = stack.pop()</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            root = node.right</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_helper</span><span class=\"params\">(self, node, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self._helper(node.left, ans)</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            self._helper(node.right, ans)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self._helper(root, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><h2 id=\"post-order\">Post-order<a href=\"#post-order\" title=\"Post-order\"></a></h2><p><code>Post-order</code> 则是在遍历过整个树之后（左侧的节点更优先），再进行值的访问。从根节点 <code>&quot;1&quot;</code> 开始，将<code>stack</code>初始化为 <code>[root]</code>。循环流程：将 <code>stack1</code>最顶端的节点pop出来作为<code>curNode</code>，并访问它的值写入最终结果的<code>stack2</code>里面将它的两个子节点全部push到<code>stack</code>里面，直到分支尽头。</p>\n<p>这里的操作其实和 <code>Pre-order</code> 几乎是一样的，唯一的区别是添加子节点的顺序。我们需要最后的结果是左侧的子节点在前。那么在使用<code>stack1</code>和<code>stack2</code>这样FILO的数据结构时，我们需要左侧子节点在结果<code>stack2</code>顶部，则需要将左侧节点优先于右侧push到<code>stack1</code>里面。这样才能是左侧节点更晚的被转移进<code>stack2</code>，即保持在相对顶部的位置。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Data%20Structure%20and%20Algorithm/post-order_tree.gif\" class=\"φcy\" alt=\"post-order\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal_iter</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        stack, ans = [root], []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> stack:</span><br><span class=\"line\">            curNode = stack.pop()</span><br><span class=\"line\">            <span class=\"keyword\">if</span> curNode:</span><br><span class=\"line\">                stack.append(curNode.left)</span><br><span class=\"line\">                stack.append(curNode.right)</span><br><span class=\"line\">                ans.append(curNode.val)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans[::<span class=\"number\">-1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_helper</span><span class=\"params\">(self, node, ans)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node:</span><br><span class=\"line\">            self._helper(node.left, ans)</span><br><span class=\"line\">            self._helper(node.right, ans)</span><br><span class=\"line\">            ans.append(node.val)</span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorderTraversal</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        ans = []</span><br><span class=\"line\">        self._helper(root, ans)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><h1 id=\"二叉树中的递归\">二叉树中的递归<a href=\"#二叉树中的递归\" title=\"二叉树中的递归\"></a></h1><p>递归是树结构的一个特性，因此递归是解决树相关问题的有效又常用的方法。对每个递归层级，我们可以只关注该问题针对一个节点并递归地去解决他的子节点。</p>\n<h2 id=\"top-down\">Top-down<a href=\"#top-down\" title=\"Top-down\"></a></h2><p><code>Top-down</code> 意味着，在每一次递归中，我们访问一个节点，得到某些值，并将这些值传递给子节点递归调用的函数。这个方法就与之前的 <code>pre-order</code> 类似。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return specific value for null node</span><br><span class=\"line\">update the answer if needed                      &#x2F;&#x2F; answer &lt;-- params</span><br><span class=\"line\">left_ans &#x3D; top_down(root.left, left_params)      &#x2F;&#x2F; left_params &lt;-- root.val, params</span><br><span class=\"line\">right_ans &#x3D; top_down(root.right, right_params)   &#x2F;&#x2F; right_params &lt;-- root.val, params </span><br><span class=\"line\">return the answer if needed                      &#x2F;&#x2F; answer &lt;-- left_ans, right_ans</span><br></pre></td></tr></table></figure><p>以寻找树的最大深度为例，我们创建一个变量 <code>depth</code> 来记录树的深度。解决问题的函数为 <code>maxDepth(node, depth)</code>。这个函数的伪代码就是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return if root is null</span><br><span class=\"line\">if root is a leaf node:</span><br><span class=\"line\">\tanswer &#x3D; max(answer, depth)         &#x2F;&#x2F; update the answer if needed</span><br><span class=\"line\">maximum_depth(root.left, depth + 1)      &#x2F;&#x2F; call the function recursively for left child</span><br><span class=\"line\">maximum_depth(root.right, depth + 1)     &#x2F;&#x2F; call the function recursively for right child</span><br></pre></td></tr></table></figure><p>具体的Python实现如下面的代码片段。因为作用域的关系且Python里面是无法规定pass by value还是pass by reference，我们无法直接对answer做直接的修改（Python中对于数值e.g.<code>int</code>、<code>float</code>和一些较为复杂的类e.g.<code>list</code>，它们的引用方式是有一点区别的。观察感觉是前者传值，后者传引用）。因此需要一个global variable，而在类里面可以用一个attribute代替。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        self.ans = <span class=\"number\">0</span></span><br><span class=\"line\">        self._helper(root, <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.ans</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_helper</span><span class=\"params\">(self, node, depth)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> node:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> node.left == node.right == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            self.ans = max(self.ans, depth)</span><br><span class=\"line\">        self._helper(node.left, depth+<span class=\"number\">1</span>)</span><br><span class=\"line\">        self._helper(node.right, depth+<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><h2 id=\"bottom-up\">Bottom-up<a href=\"#bottom-up\" title=\"Bottom-up\"></a></h2><p><code>Bottom-up</code>就是另外一种递归思路了，我们递归地对每一个子节点调用函数，然后通过这些值获得返回给父级节点的结果。这样从最尽头的子节点开始的方式就很类似<code>Post-order</code>。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> specific value <span class=\"keyword\">for</span> null node</span><br><span class=\"line\">left_ans = bottom_up(root.left)          // call function recursively <span class=\"keyword\">for</span> left child</span><br><span class=\"line\">right_ans = bottom_up(root.right)        // call function recursively <span class=\"keyword\">for</span> right child</span><br><span class=\"line\"><span class=\"keyword\">return</span> answers                           // answer &lt;-- left_ans, right_ans, root.val</span><br></pre></td></tr></table></figure><p>依然用求树的最大深度为例，对于一个根节点，其左节点为<code>l</code>有节点为<code>r</code>。这两个节点，各自递归获得它们子树（subtree）的深度。则对于根节点来讲，深度为<code>x = max(l, r)+1</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return 0 if root is null                 &#x2F;&#x2F; return 0 for null node</span><br><span class=\"line\">left_depth &#x3D; maximum_depth(root.left)</span><br><span class=\"line\">right_depth &#x3D; maximum_depth(root.right)</span><br><span class=\"line\">return max(left_depth, right_depth) + 1  &#x2F;&#x2F; return depth of the subtree rooted at root</span><br></pre></td></tr></table></figure><p>之所以会出现<code>+1</code>，是因为对于最深处的节点来讲，左右都是 <code>Null</code>，他自己本身这一level的深度其实是<code>1</code>。另外，对于某些只有一侧节点的情况也需要注意一下。下面是具体的Python代码实现，看上去就简洁很多。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span><span class=\"params\">(object)</span>:</span>    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">maxDepth</span><span class=\"params\">(self, root)</span>:</span></span><br><span class=\"line\">        <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        :type root: TreeNode</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        \"\"\"</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> root == <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><h1 id=\"总结\">总结<a href=\"#总结\" title=\"总结\"></a></h1><p>非常透彻的理解和找到合适的递归方法是很不容易的。需要根据具体情况来决定使用<code>top-down</code>还是<code>bottom-top</code>。（这不是废话吗）</p>\n<h1 id=\"reference\">Reference<a href=\"#reference\" title=\"Reference\"></a></h1><ul><li><a href=\"http://yucoding.blogspot.com/2014/03/re-view-tree-traversal-preorder-inorder.html\" target=\"_blank\">Yu’s Coding Garden - Tree Traversal</a></li>\n</ul>","prev":{"title":"Binary Tree（2）","link":"post/Tree-02"},"next":{"title":"牛顿法","link":"post/牛顿法"},"plink":"https://magi003769.github.io/post/Tree-01/","toc":[{"id":"二叉树","title":"二叉树","index":"1"},{"id":"二叉树遍历","title":"二叉树遍历","index":"2","children":[{"id":"preorder","title":"Preorder","index":"2.1"},{"id":"in-order","title":"In-order","index":"2.2"},{"id":"post-order","title":"Post-order","index":"2.3"}]},{"id":"二叉树中的递归","title":"二叉树中的递归","index":"3","children":[{"id":"top-down","title":"Top-down","index":"3.1"},{"id":"bottom-up","title":"Bottom-up","index":"3.2"}]},{"id":"总结","title":"总结","index":"4"},{"id":"reference","title":"Reference","index":"5"}]}