{"title":"Java线程的同步方法与死锁","date":"2020-05-14T07:00:00.000Z","date_formatted":{"ll":"May 14, 2020","L":"05/14/2020","MM-DD":"05-14"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1553087927-8b09bfbf19b5.jpeg","link":"post/Java多线程的同步方法与死锁","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-14T21:42:43.748Z","content":"<p>上一篇提出了Java多线程共享变量的同步问题，比因此引入了原子性、<code>sychronized</code>关键词以及锁等概念。这一片具体讲多线程同步方法、锁的重入与死锁的概念。</p>\n<a id=\"more\"></a><h1 id=\"同步方法\">同步方法<a href=\"#同步方法\" title=\"同步方法\"></a></h1><p>使用<code>synchronized</code>关键字进行线程同步的过程中，锁住的是哪个对象非常重要。如果一直使用自定义的实例来进行同步，会造成代码逻辑上的混乱，不利于封装。最有效的办法就是直接将<code>synchronized</code>逻辑也封装起来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> syncronized <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        count -= n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>上面给出的<code>Counter</code>类，里面增减的方法都用<code>synchronized</code>修饰了。这样直接用关键字修饰的效果等价于锁住当前实例<code>sychronized(this)</code>。因此，同一实例下的增减方法需要有获取锁的过程，而不同实例的方法之间互不影响，可以并发执行。</p>\n<blockquote>\n<p>用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。</p>\n</blockquote>\n<p>增减方法都是依赖于实例的类方法，那么如果我们给一个静态方法加上<code>synchronized</code>关键字修饰，那么它锁住的对象又是哪一个呢？对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。</p>\n<blockquote>\n<p>用<code>synchronized</code>修饰的方法就是同步静态方法，它表示整个方法都必须用<code>Class</code>实例加锁。</p>\n</blockquote>\n<h2 id=\"线程安全\">线程安全<a href=\"#线程安全\" title=\"线程安全\"></a></h2><p>如果一个类被设计成允许多线程正确访问，那么就称其为<strong>线程安全</strong>。Java标准库中有以下几类是线程安全的：</p>\n<ul><li><code>java.lang.StringBuffer</code>是线程安全的</li>\n<li>不变类：<code>String</code>、<code>Integer</code>、<code>LocalDate</code>等，它们的所有成员变量都用<code>final</code>修饰只能读取，不能修改</li>\n<li>只提供静态方法的类，比如<code>Math</code>，没有成员变量</li>\n</ul><p>除了这几种情况之外，绝大多数的类都是非线程安全的，不能够在多线程中进行修改。但如果这样的类只是被多线程读取而没有写入，那么它们也可以安全的被线程共享。</p>\n<h1 id=\"锁的重入\">锁的重入<a href=\"#锁的重入\" title=\"锁的重入\"></a></h1><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dec(-n);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">dec</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        count -= n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>当我们有一个线程执行<code>add</code>方法时，我们可能会执行内部对<code>dec</code>方法的调用。而两个方法都是有<code>synchronized</code>进行修饰，所以执行都要获取锁。那么<strong>对于同一个线程</strong>，我们是不是可以在获取到锁之后继续获取同一个锁呢？</p>\n<p>确实可以。<strong>JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</strong>由于Java的线程锁是可重入锁，因此在获取锁的时候，既要判断是不是第一次获取锁，还要记录是第几次获取。没获取一次，计数+1；每退出一个<code>synchronized</code>块儿，计数-1。直到真正计数为0才会真正的释放锁。</p>\n<h1 id=\"死锁\">死锁<a href=\"#死锁\" title=\"死锁\"></a></h1><p>死锁是指多线程各自持有不同的锁，而又试图获取其他线程持有的锁。这个过程各个线程都需要等待对方释放锁，而自身的所却无法释放。这就造成了一个死循环，大家都要一直等待下去。如下图就简单说明了两个线程形成死锁的状态。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Java/%E6%AD%BB%E9%94%81.png\" class=\"φcy\" alt=\"死锁\"></p>\n<p>产生死锁之后，没有任何机制可以解除，只能强制退出JVM。所以在编写多线程代码时需要特别注意避免死锁：<strong>保证线程获取锁的顺序一致。</strong></p>\n<h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><ul><li>用<code>synchronized</code>修饰方法可以把整个方法变为同步代码块，<code>synchronized</code>方法加锁对象是<code>this</code></li>\n<li><code>synchronized</code>修饰静态方法，加锁对象是JVM产生的<code>Class</code>实例</li>\n<li>通过合理的设计和数据封装可以让一个类变为“线程安全”</li>\n<li>一个类没有特殊说明，默认不是线程安全；</li>\n<li>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析（例如只读不写）</li>\n<li><code>sychronized</code>获取的锁是可以重入的</li>\n<li>死锁指多线程各自持有不同的锁，并试图获取其他线程的锁</li>\n<li>多线程获取锁的顺序保持一致可以避免死锁</li>\n</ul><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n<li>Java并发编程的艺术</li>\n</ul>","prev":{"title":"Java多线程的几种Lock","link":"post/Java多线程使用ReentrantLock等"},"next":{"title":"Java多线程之间的协调","link":"post/Java多线程之间的协调"},"plink":"https://magi003769.github.io/post/Java多线程的同步方法与死锁/","toc":[{"id":"同步方法","title":"同步方法","index":"1","children":[{"id":"线程安全","title":"线程安全","index":"1.1"}]},{"id":"锁的重入","title":"锁的重入","index":"2"},{"id":"死锁","title":"死锁","index":"3"},{"id":"summary","title":"Summary","index":"4"},{"id":"references","title":"References","index":"5"}]}