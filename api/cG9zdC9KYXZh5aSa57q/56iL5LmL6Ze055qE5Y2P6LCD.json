{"title":"Java多线程之间的协调","date":"2020-05-14T07:00:00.000Z","date_formatted":{"ll":"May 14, 2020","L":"05/14/2020","MM-DD":"05-14"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1455461491901-a0990c10d84c.jpeg","link":"post/Java多线程之间的协调","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-15T06:03:49.525Z","content":"<p>前面多线程相关的post介绍了线程的同步、<code>synchronized</code>关键字的使用、加锁以及死锁等概念。<code>synchronized</code>可以解决多线程竞争的问题，竞争使用共享变量的问题。但是它并没有解决多线程之间的协调问题。本篇介绍一下线程之间如何进行协调、<code>wait()</code>和<code>notify()</code>的用法。</p>\n<a id=\"more\"></a><p>以一个简单的任务管理器做例子，添加任务和获取任务两个方法都用<code>synchronized</code>加锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>注意到<code>getTask()</code>中有一个循环，如果任务队列为空，<code>getTask()</code>将一直占据资源，而<code>addTask()</code>的线程则无法执行，整个循环将一直持续下去，永远无法退出。我们想要的执行效果应该是：</p>\n<ul><li>线程1调用<code>addTask()</code>不断向队列里添加任务；</li>\n<li>线程2调用<code>getTask()</code>获取队列中的任务。如果队列为空，该线程应该<strong>等待</strong>，直到队列中有任务。</li>\n</ul><p><strong>因此，我们应该有如下的原则来处理多线程之间的协调问题：</strong></p>\n<blockquote>\n<p><strong>多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</strong></p>\n</blockquote>\n<p>实现这样的原则需要用到<code>wait()</code>和<code>notify()</code>。我们需要对原来的方法作如下修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue.add(s);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.notify(); <span class=\"comment\">// 唤醒在this锁等待的线程</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放this锁:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.wait();</span><br><span class=\"line\">        <span class=\"comment\">// 重新获取this锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是<code>wait()</code>和<code>notify()</code>必须在当前获取的锁对象上调用，所以具体实现中的代码是<code>this.wait()</code>和<code>this.notify()</code>。</strong></p>\n<p>调用<code>wait()</code>会使当前线程进入等待状态，此时该线程会暂时释放<code>this</code>锁，使得其他线程能够获得<code>this</code>锁。<code>wait()</code>方法不会返回，直到被其他线程<strong>唤醒</strong>，<code>wait()</code>返回并获取锁，执行后续的代码。它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。另外，<strong>必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法</strong></p>\n<p>而<code>notify()</code>则可以唤醒其他正在等待的线程。这一行语句执行之后，<code>addTask</code>也执行完成会释放<code>this</code>锁，供其他线程使用。需要注意的是，<code>notify()</code><strong>只会唤醒某一个</strong>正在等待<code>this</code>锁的线程，具有一定的随机性。所以使用<code>notifyAll()</code>实际上会更安全一些，避免有些线程没有机会被唤醒而永远等待。</p>\n<h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><ul><li>在<code>synchronized</code>内部可以调用<code>wait()</code>使线程进入等待状态；</li>\n<li>必须在已获得的锁对象上调用<code>wait()</code>方法；</li>\n<li>在<code>synchronized</code>内部可以调用<code>notify()</code>或<code>notifyAll()</code>唤醒其他等待线程；</li>\n<li>必须在已获得的锁对象上调用<code>notify()</code>或<code>notifyAll()</code>方法；</li>\n<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>\n</ul><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n<li>Java并发编程的艺术</li>\n</ul>","prev":{"title":"Java线程的同步方法与死锁","link":"post/Java多线程的同步方法与死锁"},"next":{"title":"Java线程的同步与锁","link":"post/Java线程的同步与锁"},"plink":"https://magi003769.github.io/post/Java多线程之间的协调/","toc":[{"id":"summary","title":"Summary","index":"1"},{"id":"references","title":"References","index":"2"}]}