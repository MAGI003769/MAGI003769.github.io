{"title":"Java多线程基础","date":"2020-05-11T07:00:00.000Z","date_formatted":{"ll":"May 11, 2020","L":"05/11/2020","MM-DD":"05-11"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/index-bg.jpg","link":"post/Java多线程基础","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-12T08:52:49.154Z","content":"<p>多线程几乎是开发必考的问题，需要梳理一下相关的知识和概念。进程与线程的关系、从JVM的角度分析二者、并发与并行的区别、为什么要使用多线程以及使用多线程可能带来的问题。</p>\n<a id=\"more\"></a><h1 id=\"进程与线程\">进程与线程<a href=\"#进程与线程\" title=\"进程与线程\"></a></h1><p>从简单的日常使用出发，我们可以说运行的文本编辑器、音乐播放器以及浏览器都分别是一个<strong>进程</strong>。</p>\n<blockquote>\n<p>进程是程序一次执行的过程，是系统运行程序的<strong>基本单位</strong>。</p>\n</blockquote>\n<p>进程是动态的，系统运行一个程序就是一个进程从创建、运行再到消亡的过程。但是操作系统调度的最小单元不是进程而是<strong>线程</strong>，二者之间是一种包含关系。</p>\n<blockquote>\n<p>线程是操作系统调度的最小单元。它比进程更小，可以看做轻量级的进程，一个进程可以包括单个或多个线程。</p>\n</blockquote>\n<p>多个线程会共享一部分资源（<strong>堆和方法区</strong>），而进程则各自有相对独立的内存资源。因此线程之间的相互切换的开销跟进程相比要小很多。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Java/%E5%9B%BE%E5%83%8F.png\" class=\"φcy\" alt=\"线程和进程\"></p>\n<h2 id=\"进程vs线程\">进程vs线程<a href=\"#进程vs线程\" title=\"进程vs线程\"></a></h2><p>两者的优缺点上讲，多进程的优点在于稳定性相比多线程要高，一个进程崩溃了并不影响其他进程，而多线程的情况下任何线程崩溃则可能导致整个进程崩溃。虽然多进程有稳定性上的优势，然而却有前面提到了开销的问题，具体在以下两个方面：</p>\n<ul><li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>\n<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>\n</ul><h2 id=\"java的多线程\">Java的多线程<a href=\"#java的多线程\" title=\"Java的多线程\"></a></h2><p>Java实际上内置了多线程：一个Java进程是一个JVM进程，程序的主线程执行<code>main()</code>方法，而在<code>main()</code>内部我们可以启动多个线程。另外在程序执行期间，JVM还有负责垃圾回收的其他工作线程。常用的Windows、Linux等操作系统都采用抢占式多任务，<strong>如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间</strong>。</p>\n<p>因此，对大多数Java程序来说，实现多任务实际上通常是指如何用多线程实现多任务。Java多线程的特点就在于：</p>\n<ul><li><strong>多线程模型是Java最基本的并发模型</strong></li>\n<li>后续读写网络、数据库、web开发基本都依赖于多线程。</li>\n</ul><p>核单线程相比，多线程容易带来的问题在于：<strong>数据需要共享合同步</strong>。我们使用多线程实现并发编程，是为了更高的效率，但由于部分资源和数据是共享的，就会出现一些具体问题，例如：<strong>内存泄漏、上下文切换、死锁以及资源限制。</strong></p>\n<h2 id=\"并发与并行\">并发与并行<a href=\"#并发与并行\" title=\"并发与并行\"></a></h2><p>上面提到了并发，这里注意区分一下并发与并行的概念：</p>\n<ul><li><strong>并发：</strong>同一时段，多个任务都在执行<strong>（单位时间内不一定同时执行）</strong></li>\n<li><strong>并行：</strong>单位时间内，多个任务同时执行</li>\n</ul><p>一个是来回切换，另一个是严格意义上的同时进行。</p>\n<h1 id=\"jvm的视角\">JVM的视角<a href=\"#jvm的视角\" title=\"JVM的视角\"></a></h1><p>下面是抽象的Java运行时的内存区域。我们可以看到，<strong>同一进程下的多个线程有共享资源，也有各自私有的资源</strong>：</p>\n<ul><li><strong>共享资源：堆和方法区</strong></li>\n<li><strong>私有资源：虚拟机栈、本地方法栈、程序计数器</strong></li>\n</ul><p>每个进程的资源为线程所共享，进程可以在多CPU的情况下同时运行，而线程则因为共享相同的资源而需要在CPU的调度下分时段执行。</p>\n<p><img src=\"https://post-pic.nos-eastchina1.126.net/Java/JVM-memory.jpg\" class=\"φcy\" alt=\"JVM\"></p>\n<h2 id=\"堆和方法区\">堆和方法区<a href=\"#堆和方法区\" title=\"堆和方法区\"></a></h2><p>堆和方法区是所有线程的共享资源，其中堆是最大的一块内存区域，主要用于新创建的对象（所有的对象都是在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<h2 id=\"为什么会有私有的部分\">为什么会有私有的部分<a href=\"#为什么会有私有的部分\" title=\"为什么会有私有的部分\"></a></h2><p><strong>程序计数器：</strong>它的作用是实现代码流程控制，因此当我们使用多线程在不同线程之间来回切换的时候，则需要记住当前执行到的位置，保证下次在其换回来的时候能继续按照指令运行。</p>\n<p><strong>剩下两个，都是为了保证局部变量不被其他线程访问到而私有的。</strong></p>\n<p><strong>虚拟机栈：</strong>Java<strong>方法</strong>在执行时都会创建一个栈帧用于储存局部变量表、操作数栈、常量池引用等信息。从方法调用，直到完成的过程都对应着一个栈帧在虚拟机栈中入栈和出栈的过程。因此通常说的Stack Overflow其实是发生在这个位置。</p>\n<p><strong>本地方法栈：</strong>这个其实作用和虚拟机栈差不多，区别在于这里的方法是JVM中C/C++实现的Native方法，为虚拟机使用到的Native方法提供服务。</p>\n<h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n</ul>","prev":{"title":"Java线程的同步与锁","link":"post/Java线程的同步与锁"},"next":{"title":"MAC上配置Hexo部署GitHub Page","link":"post/MAC-hexo"},"plink":"https://magi003769.github.io/post/Java多线程基础/","toc":[{"id":"进程与线程","title":"进程与线程","index":"1","children":[{"id":"进程vs线程","title":"进程vs线程","index":"1.1"},{"id":"java的多线程","title":"Java的多线程","index":"1.2"},{"id":"并发与并行","title":"并发与并行","index":"1.3"}]},{"id":"jvm的视角","title":"JVM的视角","index":"2","children":[{"id":"堆和方法区","title":"堆和方法区","index":"2.1"},{"id":"为什么会有私有的部分","title":"为什么会有私有的部分","index":"2.2"}]},{"id":"references","title":"References","index":"3"}]}