{"title":"Java多线程的几种Lock","date":"2020-05-15T07:00:00.000Z","date_formatted":{"ll":"May 15, 2020","L":"05/15/2020","MM-DD":"05-15"},"thumbnail":"https://post-pic.nos-eastchina1.126.net/header_imgs/photo-1501959181532-7d2a3c064642.jpeg","link":"post/Java多线程使用ReentrantLock等","tags":["Java","多线程"],"categories":["Java"],"updated":"2020-05-16T08:26:11.236Z","content":"<p>前面多线程相关的post介绍了线程的同步、<code>synchronized</code>关键字的使用、加锁以及死锁等概念。这一篇介绍一下Java提供的其他加锁机制：使用<code>ReentrantLock</code>，以及配合<code>Condition</code>实现多线程之间的协调。另外，还会介绍<code>ReadWriteLock</code>和<code>StampedLock</code>两种锁。</p>\n<a id=\"more\"></a><h1 id=\"reentrantlock\">ReentrantLock<a href=\"#reentrantlock\" title=\"ReentrantLock\"></a></h1><p>之前提到Java提供了<code>synchronized</code>关键字来实现加锁，但他的缺点在与比较重，而且获取是只能等待，没有额外尝试的机会。<code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁。</p>\n<p>之前利用<code>synchronized</code>加锁的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>换用<code>ReentrantLock</code>的代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>我们使用<code>lock.lock()</code>来获取锁，<code>lock.unlock()</code>来释放锁。注意这里使用了<code>try{...}</code>语句块，这说明我们需要考虑异常。<code>finally{...}</code>保证不论何种情况都会释放锁。</p>\n<p><code>ReentrantLock</code>也是重入锁，一个线程可以多次获取相同的锁。<code>lock()</code>方法在资源可用时起上锁的作用，而如果是重入则计次+1；<code>unlock()</code>反之。</p>\n<p>另外，<code>ReentrantLock</code>提供了尝试获取锁的的功能，可以不像<code>synchronized</code>那样一直等待。如果在指定时间内无法获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是一直等待下去。因此，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lock.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        lock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"reentrantlock与sychronized比较\">ReentrantLock与sychronized比较<a href=\"#reentrantlock与sychronized比较\" title=\"ReentrantLock与sychronized比较\"></a></h2><ol><li>两者都是可重入锁</li>\n<li><code>synchronized</code>是Java语言层面提供的语法，它的实现以及性能依赖于JVM；<code>ReentrantLock</code>则是JDK层面的实现，也就是API（调用<code>lock()</code>和<code>unlock()</code>方法并配合<code>try/finally</code>使用）</li>\n<li><code>ReentrantLock</code>具有更多功能：<ul><li>等待可中断</li>\n<li>可实现公平锁</li>\n<li>可实现选择性通知（锁可以绑定多个条件）</li>\n</ul></li>\n<li>性能不再是选择的标准</li>\n</ol><h1 id=\"condition\">Condition<a href=\"#condition\" title=\"Condition\"></a></h1><p>前面提到<code>ReentrantLock</code>可以替代<code>synchronized</code>来解决线程的同步问题。但是之前的post里面也提到<code>synchronized</code>可以配合<code>wait()</code>和<code>notify()</code>来实现线程之间的协调。那么使用<code>ReentrantLock</code>时应该怎么实现这种功能呢？答案是使用<code>Condition</code>类来实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Condition condition = lock.newCondition(); <span class=\"comment\">// 创建Condition实例</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            queue.add(s);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                condition.await();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue.remove();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>Condition</code>实例，必须通过<code>lock</code>对象调用<code>newCondition()</code>来创建，这样这个<code>Condition</code>实例才能跟对应的锁绑定。一个<code>Condition</code>实例提供了<code>await()</code>、<code>signal()</code>以及<code>signalAll()</code>方法来实现协调：</p>\n<ul><li><code>await()</code>会释放当前锁，使线程进入等待状态</li>\n<li><code>signal()</code>唤醒<strong>某一个</strong>正在等待的线程</li>\n<li><code>signalAll()</code>唤醒正在等待的所有线程</li>\n<li><code>await()</code>返回之后，当前线程会重新获取锁</li>\n</ul><p><code>Condition</code>同样提供了类似于<code>tryLock()</code>尝试获取锁的功能。如果没有在指定时间内被其他线程唤醒，那么就自己醒过来返回<code>false</code>，执行其他操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition.await(<span class=\"number\">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 被其他线程唤醒</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 指定时间内没有被其他线程唤醒</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>ReentrantLock</code>配合<code>Condition</code>使用也可以实现灵活的线程同步。</p>\n<h1 id=\"readwritelock\">ReadWriteLock<a href=\"#readwritelock\" title=\"ReadWriteLock\"></a></h1><p>考虑一个<code>Counter</code>实例有<code>inc()</code>和<code>get()</code>两个方法。前者允许读写，后者只读。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inc</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果我们像上面这段代码一样使用<code>ReentrantLock</code>加锁，那么一旦有某个线程获取锁，那么其他线程不论操作是要读取还是修改，都必须等待。如果线程只是要读取而不修改，这种情况的多线程会损失一些性能。实际上我们是希望他们的能够同时进行的，也就是：<strong>允许多线程同时读取，但只能有一个线程修改。</strong></p>\n<p>使用<code>ReadWriteLock</code>加锁就可以实现这样的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock rwlock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock wlock = rwlock.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inc</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        wlock.lock(); <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            wlock.unlock(); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">        rlock.lock(); <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rlock.unlock(); <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>从代码层面来看，实际上是我们可以从一个<code>ReadWriteLock</code>实例中分别获取两个锁：<code>rlock</code>和<code>wlock</code>，并分别用于给读取和修改的代码逻辑加锁。这样就可以提高并发读取的效率，因此<code>ReadWriteLock</code>适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>\n<p><strong>需要注意的是，使用<code>ReadWriteLock</code>加锁，当有线程在读取时，其他线程的读取操作是被允许的，但是修改操作是不被允许的。</strong></p>\n<h1 id=\"stampedlock\">StampedLock<a href=\"#stampedlock\" title=\"StampedLock\"></a></h1><p>从<code>ReentrantLock</code>到<code>ReadWriteLock</code>的改进是为了提升多线程读取的效率，那么还有没有办法进一步提升效率呢？为此Java8引入了新的读写锁<code>StampedLock</code>。它与<code>ReadWriteLock</code>的区别在于对写入线程的处理，讨论起来需要引入乐观锁和悲观锁的概念。</p>\n<h2 id=\"乐观锁和悲观锁\">乐观锁和悲观锁<a href=\"#乐观锁和悲观锁\" title=\"乐观锁和悲观锁\"></a></h2><p>乐观锁和悲观锁主要是指对待读写操作的不同策略，而不是只具体的锁。</p>\n<blockquote>\n<p><strong>悲观锁：</strong>认为读取时，一定存在修改的线程。必须等到读取线程释放锁后，才允许修改。这样再有线程读取的情况下，修改线程就会被阻塞。</p>\n<p><strong>乐观锁：</strong>认为在读取时，其他线程有修改操作的概率很小。需要检查读取后检查执行过程中是否有线程进行了修改操作，如果有再获取锁重新读取。</p>\n</blockquote>\n<p>于是我们可以发现，<code>ReadWriteLock</code>是一种悲观的读锁，而<code>StampedLock</code>属于乐观的读锁。</p>\n<h2 id=\"stampedlock的例子\">StampedLock的例子<a href=\"#stampedlock的例子\" title=\"StampedLock的例子\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock stampedLock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">double</span> deltaX, <span class=\"keyword\">double</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            x += deltaX;</span><br><span class=\"line\">            y += deltaY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            stampedLock.unlockWrite(stamp); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">distanceFromOrigin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.tryOptimisticRead(); <span class=\"comment\">// 获得一个乐观读锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意下面两行代码不是原子操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设x,y = (100,200)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentX = x;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentY = y;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果有写入，读取是错误的(100,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stampedLock.validate(stamp)) &#123; <span class=\"comment\">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class=\"line\">            stamp = stampedLock.readLock(); <span class=\"comment\">// 获取一个悲观读锁</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                currentX = x;</span><br><span class=\"line\">                currentY = y;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                stampedLock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>和<code>ReadWriteLock</code>相比，写入部分的加锁几乎是一样的，只是返回获取了一个<code>stamp</code>变量。这个变量会在写如操作结束释放锁的时候作为参数，与乐观锁的验证有关。</p>\n<p>变化较大的地方是读取的部分。我们会先试用<code>stampedLock.tryOptimisticRead()</code>获取一个乐观锁，比得到一个<code>stamp</code>作为”版本号”。之后我们会使用<code>stampedLock.validate(stamp)</code>来验证这个”版本号”来验证读取过程中是否有其他写入线程修改了我们读取的变量。如果验证失败，会重新获取一个悲观锁来进行重新读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>\n<p>可见，<code>stampedLock</code>将读锁细分成了乐观锁和悲观锁两种，来进一步提升多线程的效率。但是作为代价，我们需要更多的代码来实现和处理悲观锁可能带来的异常（写法和<code>ReentrantLock</code>类似）。</p>\n<h1 id=\"summary\">Summary<a href=\"#summary\" title=\"Summary\"></a></h1><h2 id=\"reentrantlock相关\"><code>ReentrantLock</code>相关<a href=\"#reentrantlock相关\" title=\"ReentrantLock相关\"></a></h2><ul><li><code>ReentrantLock</code>提供了另一种多线程的同步方式，可以替代<code>synchronized</code>，并且更安全；</li>\n<li>必须先获取到锁，再进入<code>try {...}</code>代码块，最后使用<code>finally</code>保证释放锁；</li>\n<li>提供了<code>tryLock()</code>方法来尝试在一定时间内获取锁</li>\n</ul><h2 id=\"condition相关\"><code>Condition</code>相关<a href=\"#condition相关\" title=\"Condition相关\"></a></h2><ul><li>实例必须通过<code>ReentrantLock</code>的<code>newCondition()</code>方法获取，做到条件与锁绑定</li>\n<li>提供<code>await()</code>和<code>signalAll()</code>来实现线程之间的协调</li>\n</ul><h2 id=\"readwritelock相关\"><code>ReadWriteLock</code>相关<a href=\"#readwritelock相关\" title=\"ReadWriteLock相关\"></a></h2><ul><li>允许多线程同时读取数据，以提高效率</li>\n<li>只允许一个线程写入</li>\n<li>读锁和写锁被细分，分别通过<code>readLock()</code>和<code>writeLock()</code>获取</li>\n</ul><h2 id=\"stampedlock相关\"><code>StampedLock</code>相关<a href=\"#stampedlock相关\" title=\"StampedLock相关\"></a></h2><ul><li><p>引入乐观锁，进一步提升效率</p>\n</li>\n<li><p>读锁细分为乐观锁和悲观锁，<strong>乐观读锁实际不上锁</strong>，有可能有线程写入</p>\n</li>\n<li><p><code>StampedLock</code>不可重入</p>\n</li>\n</ul><h1 id=\"references\">References<a href=\"#references\" title=\"References\"></a></h1><ul><li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185\" target=\"_blank\">廖雪峰Java教程</a></li>\n<li><a href=\"https://www.runoob.com/java/java-multithreading.html\" target=\"_blank\">Bunoob - Java教程</a></li>\n<li><a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\">Java Guide</a></li>\n<li>Java并发编程的艺术</li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/71156910\" target=\"_blank\">Java的各种锁</a></li>\n</ul>","prev":{"title":"Java的Concurrent集合和Atomic类","link":"post/Java的Concurrent集合和Atomic类"},"next":{"title":"Java线程的同步方法与死锁","link":"post/Java多线程的同步方法与死锁"},"plink":"https://magi003769.github.io/post/Java多线程使用ReentrantLock等/","toc":[{"id":"reentrantlock","title":"ReentrantLock","index":"1","children":[{"id":"reentrantlock与sychronized比较","title":"ReentrantLock与sychronized比较","index":"1.1"}]},{"id":"condition","title":"Condition","index":"2"},{"id":"readwritelock","title":"ReadWriteLock","index":"3"},{"id":"stampedlock","title":"StampedLock","index":"4","children":[{"id":"乐观锁和悲观锁","title":"乐观锁和悲观锁","index":"4.1"},{"id":"stampedlock的例子","title":"StampedLock的例子","index":"4.2"}]},{"id":"summary","title":"Summary","index":"5","children":[{"id":"reentrantlock相关","title":"ReentrantLock相关","index":"5.1"},{"id":"condition相关","title":"Condition相关","index":"5.2"},{"id":"readwritelock相关","title":"ReadWriteLock相关","index":"5.3"},{"id":"stampedlock相关","title":"StampedLock相关","index":"5.4"}]},{"id":"references","title":"References","index":"6"}]}